<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库复习</title>
      <link href="/2021/12/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
      <url>/2021/12/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-DBS概述"><a href="#1-1-DBS概述" class="headerlink" title="1.1 DBS概述"></a>1.1 DBS概述</h2><h3 id="1-1-1-四个基本概念"><a href="#1-1-1-四个基本概念" class="headerlink" title="1.1.1 四个基本概念"></a>1.1.1 四个基本概念</h3><p>数据data：描述事物的<strong>符号记录</strong>。<br>数据库DB：长期存储在计算机内的、有组织的、可共享的大量数据集合。<br>数据库管理系统DBMS：是位于用户与操作系统之间的具有数据定义、数据操纵、数据库的运行管理、数据库的建立和维护功能的一层数据管理软件。<br>数据库系统DBS：在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员<strong>DBA</strong>和用户构成。<br>DDL：数据定义语言(Data Definition Launguage)。<br>DML：数据操纵语言(Data Manipulation Launguage)。  </p><h3 id="1-1-2-数据管理的三个阶段"><a href="#1-1-2-数据管理的三个阶段" class="headerlink" title="1.1.2 数据管理的三个阶段"></a>1.1.2 数据管理的三个阶段</h3><table><thead><tr><th></th><th>人工管理阶段</th><th>文件系统阶段</th><th>数据库系统阶段</th></tr></thead><tbody><tr><td>处理方式</td><td>批处理</td><td>联机实时处理，批处理</td><td>有数据库管理系统</td></tr><tr><td>面向对象</td><td>某一个应用程序</td><td>某一个应用</td><td>现实世界</td></tr><tr><td>数据共享程度</td><td>无共享，冗余度极大</td><td>共享性差，冗余度大</td><td>共享性高，冗余度小</td></tr><tr><td>独立性</td><td>不独立，完全依赖程序</td><td>独立性差</td><td>具有高度的物理独立性和一定的逻辑独立性</td></tr></tbody></table><h3 id="1-1-3-DBS的特点"><a href="#1-1-3-DBS的特点" class="headerlink" title="1.1.3 DBS的特点"></a>1.1.3 DBS的特点</h3><p>1. <strong>数据结构化</strong></p><p>2. 数据<strong>共享性高</strong>、冗余度低<strong>且易扩充</strong></p><p>3. 数据独立性高</p><blockquote><p>物理独立性：应用程序与数据库中<strong>数据的物理存储</strong>是相互独立的</p><p>逻辑独立性：应用程序与<strong>数据库的逻辑结构</strong>是相互独立的，数据的逻辑结构改变时用户程序可以不变  </p><p>数据的独立性是由<strong>二级映像决定的</strong></p></blockquote><p>4. 数据由DBMS统一管理和控制</p><h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h2><h3 id="1-2-1-两类数据模型"><a href="#1-2-1-两类数据模型" class="headerlink" title="1.2.1 两类数据模型"></a>1.2.1 两类数据模型</h3><blockquote><p>1. 概念模型（信息模型） 按用户的观点对数据和信息建模，用于DB设计</p><p>2. 逻辑和物理模型  逻辑模型用于DBMS的实现 物理模型是对底层的抽象</p></blockquote><h3 id="1-2-2-概念模型"><a href="#1-2-2-概念模型" class="headerlink" title="1.2.2 概念模型"></a>1.2.2 概念模型</h3><p>1. 实体：客观存在并可相互区别的事物</p><p>2. 属性：实体所具有的某一特性称为属性</p><p>3. 码：唯一标识实体的属性集</p><p>4. 实体型：同类实体，比如学生</p><p>5. 实体集：同一类型的集合，比如全体学生</p><p>6. 联系：实体内部联系，或者实体之间的联系，如一对一，一对多和多对多</p><p>ER图：概念模型的表示方法</p><h3 id="1-2-3-数据模型的组成要素"><a href="#1-2-3-数据模型的组成要素" class="headerlink" title="1.2.3 数据模型的组成要素"></a>1.2.3 数据模型的组成要素</h3><p>1. 数据结构（静态特性）</p><ul><li>数据结构<ul><li>关系：关系就是二维表满足以下条件：<ul><li>关系中每一列都是不可再分的属性</li><li>关系行列无序</li><li>关系中不可能出现两个完全相同的元组（实体完整性）</li></ul></li><li>属性</li><li>值域</li><li>元组</li><li>分量：元组中的每个属性值成为元组的分量</li><li>关系模式：关系的描述就是关系模式。关系模型全体数据逻辑结构的描述就是关系模式，或者说是二维表的表头。关系模式是型，是静态的，稳定的；关系是具体的值，是动态的，因为时刻在插入、修改数据。</li><li>关系数据库：对应一个关系模型的所有关系的集合</li><li>各种码及主属性<ul><li>超码:一个或多个属性的集合,这些属性的集合可以使我们在一个关系中唯一标识一个元祖</li><li>候选码:候选码是最小的超码,即候选码可以唯一标识一个元组,但是出去候选码中任何的一个属性均不能唯一标识选组</li><li>主码:当有多个候选码时可以选择一个作为主码,一个关系只有一个主码.主码能够唯一标识一个关系的元组且不含有多于的元素.</li><li>主属性:包含在任意候选码中的属性成为主属性,不包含在任意候选码中的属性叫做非主属性</li></ul></li></ul></li></ul><ol start="2"><li>数据操作：关系模式的操作对象是集合（也就是关系）</li></ol><p>而不是行。操作的数据操作的结果都是完整的表，而不是单行。</p><ol start="3"><li>数据的约束条件</li></ol><ul><li>实体完整性约束：数据库所有表中都有主码，且表中不允许存在无主码的记录和主码相同的记录</li><li>参照完整性</li><li>用户定义完整性</li></ul><h3 id="1-2-4-常用的数据模型"><a href="#1-2-4-常用的数据模型" class="headerlink" title="1.2.4 常用的数据模型"></a>1.2.4 常用的数据模型</h3><ul><li>层次模型</li><li>网状模型</li><li><strong>关系模型</strong></li><li>面向对象数据模型</li><li>对象关系数据模型</li><li>半结构化数据模型</li></ul><p>关系模型优缺点</p><blockquote><ol><li> 具有严谨的数学基础</li><li> 概念单一，数据结构简单、清晰，用户易懂</li><li> 数据独立性、安全保密性、简化开发工作</li><li> 缺点：查询效率不如格式化数据模型，需要查询优化</li></ol></blockquote><h2 id="1-3-数据库系统的结构"><a href="#1-3-数据库系统的结构" class="headerlink" title="1.3 数据库系统的结构"></a>1.3 数据库系统的结构</h2><h3 id="1-3-1-DBS模式的概念"><a href="#1-3-1-DBS模式的概念" class="headerlink" title="1.3.1 DBS模式的概念"></a>1.3.1 DBS模式的概念</h3><blockquote><p>模式是DB中<strong>全体数据</strong>的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值（实例），模式是相对稳定的，而实例是相对变动的，模式反映的是数据的结构和联系，实例反映的是DB某一时刻的状态</p></blockquote><h3 id="1-3-2-DBS的三级模式结构"><a href="#1-3-2-DBS的三级模式结构" class="headerlink" title="1.3.2 DBS的三级模式结构"></a>1.3.2 DBS的三级模式结构</h3><p>1. 外模式（external schema，用户模式）：用户能看到、使用的<strong>局部</strong>数据的<strong>逻辑结构和特征的描述</strong>，是DB用户的数据视图，是与某一应用有关的数据的逻辑表示。外模式是模式的子集，<strong>根据用户的不同而不同</strong>，一个DB可以有多个外模式。外模式是保障DB安全的有利措施，每个用户只能访问对应外模式中的数据，其余不可见。</p><p>2. 模式（逻辑模式）：DB中<strong>全体数据</strong>的<strong>逻辑结构和特征的描述</strong>，是所有用户的<strong>公共数据视图</strong>；是DB模式结构的<strong>中间层</strong>，不涉及物理存储，与应用程序也无关。<strong>一个DB只有一个模式</strong>。</p><p>3. 内模式（internal schema，存储模式）：一个DB只有一个内模式，是物理结构</p><p><strong>注：</strong></p><blockquote><p>一个关系型DBMS的实例（instance）中可建立多个数据库，<strong>一个DB中可建立多个模式（包括不同级的模式）</strong>，一个模式下通常包括多个table、视图、索引等数据库对象。</p><p>DBMS提供<strong>模式DDL</strong>来定义模式，<strong>外模式DDL</strong>来定义外模式</p></blockquote><h3 id="1-3-3-DB的二级映像功能和数据独立性"><a href="#1-3-3-DB的二级映像功能和数据独立性" class="headerlink" title="1.3.3 DB的二级映像功能和数据独立性"></a>1.3.3 DB的二级映像功能和数据独立性</h3><p>为了实现三种模式的联系和转换，DBMS提供了两层映像，正因如此，保证了DBS中的数据有较高的独立性</p><p>1. 外模式/模式映像</p><p>对于每一个外模式，DBS都有一个外模式/模式映像，它定义了该外模式和模式之间的对应关系，这些映像通常包含在各自外模式的描述中。<strong>当模式改变时</strong>，由数据库管理员对映像做相应改变，可使外模式保持不变，而应用程序是根据外模式编写的，所以也不用改，从而保证了数据和程序的逻辑独立性。</p><p>2. 模式/内模式映像</p><p>DB中只有一个模式和一个内模式，所以模式/内模式映像是<strong>唯一的。定义了数据全局逻辑结构二号存储结构之间的对应关系。当存储结构改变时</strong>，由数据库管理员对映像做相应改变，可使模式保持不变，从而应用程序不用改，从而保证了数据和程序的物理独立性。</p><p>注：</p><blockquote><p>设计DB模式结构时应首先确定数据库的全局逻辑结构，即模式（P30）</p><p>设计外模式时应充分考虑应用的扩充性（P30）</p></blockquote><h1 id="第2章-关系数据库"><a href="#第2章-关系数据库" class="headerlink" title="第2章 关系数据库"></a>第2章 关系数据库</h1><h2 id="2-1-关系数据结构及形式化定义"><a href="#2-1-关系数据结构及形式化定义" class="headerlink" title="2.1 关系数据结构及形式化定义"></a>2.1 关系数据结构及形式化定义</h2><h3 id="2-1-1-关系"><a href="#2-1-1-关系" class="headerlink" title="2.1.1 关系"></a>2.1.1 关系</h3><p>1. 域：一组具有相同数据类型的值的集合； 一个域允许的不同取值的个数成为基数</p><p>2. 笛卡儿积：每个域的基数相乘=行数,一行=元组，元组每一个值叫分量</p><p>3. 关系：笛卡儿积的<strong>有限集合</strong>，就是一张二维表，<strong>关系=表</strong></p><blockquote><ol><li> 候选码：每一个属性组的值能够唯一标识一个元组，而子集不行。候选码的诸属性为主属性。若有多个候选码，选其中一个作为主码</li><li> 全码，所有属性全是该关系模式的候选码</li><li> 关系有三种类型：基本关系（实际存在，实际数据的逻辑表示）、视图表（虚表）、查询表</li></ol></blockquote><p>基本关系具有6条性质：</p><blockquote><p>1. 列是同质的，每个元组的某个分量属于同一个域</p></blockquote><blockquote><p>2. 不同的列可能出自同一域，每一列称为属性，属性必须是不同的属性名</p></blockquote><blockquote><p>3. 列顺序无所谓</p></blockquote><blockquote><p>4. 任意元组候选码不能取相同值</p></blockquote><blockquote><p>5. 行顺序无所谓</p></blockquote><blockquote><p>6. 分量原子值，即不能表中有</p></blockquote><h3 id="2-1-2-关系模式"><a href="#2-1-2-关系模式" class="headerlink" title="2.1.2 关系模式"></a>2.1.2 关系模式</h3><p>关系模式：关系的描述，应当要刻划出完整性的约束条件</p><p>形式化表示：</p><blockquote><p>R(U,D,DOM,F)</p></blockquote><p><strong>关系实际上就是关系模式在某一时刻的状态或内容。也就是说，关系模式是型，关系是它的值。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。</strong></p><h2 id="2-2-关系操作"><a href="#2-2-关系操作" class="headerlink" title="2.2 关系操作"></a>2.2 关系操作</h2><p>增删改查</p><p>查又分为：</p><p>基本操作是：选择、投影、并、差、笛卡儿积</p><h2 id="2-3-关系的完整性"><a href="#2-3-关系的完整性" class="headerlink" title="2.3 关系的完整性"></a>2.3 关系的完整性</h2><h3 id="2-3-1-实体的完整性"><a href="#2-3-1-实体的完整性" class="headerlink" title="2.3.1 实体的完整性"></a>2.3.1 实体的完整性</h3><p>主码不能为空，若主码有多个，则都不能空</p><h3 id="2-3-2-参照完整性"><a href="#2-3-2-参照完整性" class="headerlink" title="2.3.2 参照完整性"></a>2.3.2 参照完整性</h3><p>外码</p><p>参照关系(有外码)</p><p>被参照关系（被引用的主码）</p><p>参照和被参照关系可以是同一个</p><p>外码不一定要与相应的主码同名</p><p>对于有F(外码)的R的元组，要么取空（不存在），要么取S（被参照关系）的主码</p><h3 id="2-3-3-用户定义完整性"><a href="#2-3-3-用户定义完整性" class="headerlink" title="2.3.3 用户定义完整性"></a>2.3.3 用户定义完整性</h3><h2 id="2-4-关系代数"><a href="#2-4-关系代数" class="headerlink" title="2.4 关系代数"></a>2.4 关系代数</h2><table><thead><tr><th></th><th>并</th><th>差</th><th>交</th><th>笛卡儿积</th><th>选择</th><th>投影</th><th>连接</th><th>除</th></tr></thead><tbody><tr><td>符号</td><td>∪</td><td>-</td><td>∩</td><td>x</td><td>σ</td><td>Π</td><td>⋈</td><td>÷</td></tr></tbody></table><h3 id="2-4-1-传统的集合运算"><a href="#2-4-1-传统的集合运算" class="headerlink" title="2.4.1 传统的集合运算"></a>2.4.1 传统的集合运算</h3><blockquote><p>基于行的，和集合运算无区别</p></blockquote><p>1. 并 ：两个表上下拼接</p><p>2. 差 </p><p>3. 交</p><p>4. 笛卡儿积（用R X S表示）</p><h3 id="2-4-2-专门的关系运算"><a href="#2-4-2-专门的关系运算" class="headerlink" title="2.4.2 专门的关系运算"></a>2.4.2 专门的关系运算</h3><p>1. 选择  针对行</p><p>2. 投影  针对列，也可能取消某些行，避免重复</p><p>3. 连接 ： 先做广义笛卡尔积，然后</p><blockquote><p>等值连接：从广义笛卡儿积中选取A、B<strong>属性值</strong>相等的元组（注意相等的不能合并）</p><p>自然连接：自动在公共属性（名字、值域均相同）上做等值连接，并且要在结果中把重复的属性去掉</p><p>非等值连接：从广义笛卡儿积中选择符合条件的属性列</p><p>​    在连接中被舍弃的元组为悬浮元组</p><p>​    若不舍弃，则为外连接</p><p>​    不舍弃左边关系中的，就叫左外连接</p><p>左外连接 ， 右外连接见：<a href="https://www.bilibili.com/video/BV1hE411V7vu?share_source=copy_web">参考链接</a></p></blockquote><p>4. 除</p><blockquote><p>象集：R中属性组X上的x值的诸元组在Z上分量的集合</p><p>R(X,Y),S(Y,Z),Y属于同一域<br>除的定义：元组在<strong>X</strong>上 分量值 <strong>x</strong> 的象集 <strong>Yx</strong> 包含 <strong>S</strong> 在 <strong>Y</strong> 上投影 的集合</p><p>常用于求解“查询…全部的/所有的…”</p></blockquote><p><em>除运算举例:R÷S</em> </p><table><thead><tr><th>R表</th><th></th><th></th></tr></thead><tbody><tr><td>A1</td><td>A3</td><td>A2</td></tr><tr><td>a</td><td>c</td><td>b</td></tr><tr><td>d</td><td>c</td><td>b</td></tr><tr><td>a</td><td>c</td><td>e</td></tr><tr><td>a</td><td>f</td><td>e</td></tr></tbody></table><table><thead><tr><th>S表</th><th></th></tr></thead><tbody><tr><td>A2</td><td>A3</td></tr><tr><td>b</td><td>c</td></tr></tbody></table><table><thead><tr><th>R÷S表</th></tr></thead><tbody><tr><td>A1</td></tr><tr><td>a</td></tr><tr><td>d</td></tr></tbody></table><p>结果的属性:R的属性－S的属性</p><p>结果的元组:它与S中的每个元组结合起来所形成的一个新的元组都是R中某一个元组<br>$$<br>R÷S={t|t∈Π_{R-S}(R)\wedge \forall u∈S(tu∈R) }<br>$$<br><img src="https://s2.loli.net/2021/12/04/bwUOBoijedfIhZk.png" alt="Snipaste_2021-12-04_20-17-27.png"></p><p><img src="https://s2.loli.net/2021/12/04/MsgqIcGZ8Sa2ACT.png" alt="Snipaste_2021-12-04_20-18-59.png"></p><h1 id="第3章-关系型数据库标准语言SQL"><a href="#第3章-关系型数据库标准语言SQL" class="headerlink" title="第3章 关系型数据库标准语言SQL"></a>第3章 关系型数据库标准语言SQL</h1><h2 id="3-1-SQL概述"><a href="#3-1-SQL概述" class="headerlink" title="3.1 SQL概述"></a>3.1 SQL概述</h2><h3 id="3-1-3-SQL的基本概念P78"><a href="#3-1-3-SQL的基本概念P78" class="headerlink" title="3.1.3 SQL的基本概念P78"></a>3.1.3 SQL的基本概念P78</h3><blockquote><p>外模式：包括若干视图和部分基本表，基本表是本身独立存在的表，一个关系就对应一个基本表，一个或多个基本表对应一个存储文件；视图是从一个或多个基本表导出的表，本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放其数据，数据仍存在基本表中，因此视图是虚表，视图上可以再定义视图。</p><p>模式：包括若干基本表</p><p>内模式：包含若干存储文件，<strong>存储文件的逻辑结构组成了关系数据库的内模式</strong>，存储文件的物理结构对用户是隐蔽的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先进入mysql文件夹下的bin目录，然后输入MySQL -u+用户名 -p然后输入密码，AC  musk  spacexjack  密码忘了Yang  。。。 create user 用户名 identified by &#x27;密码&#x27;; 授予权限： grant insert,update,delete on student_course to musk; 撤回权限： revoke all on student from musk;//mysql只能一次撤一个对象</span><br></pre></td></tr></table></figure><h2 id="3-3-数据定义"><a href="#3-3-数据定义" class="headerlink" title="3.3 数据定义"></a>3.3 数据定义</h2><h3 id="3-3-1-模式的定义和删除"><a href="#3-3-1-模式的定义和删除" class="headerlink" title="3.3.1 模式的定义和删除"></a>3.3.1 模式的定义和删除</h3><p>要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授权的Create schema的去哪先</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> schema &quot;S-T&quot; <span class="keyword">authorization</span> wang;#为用户wang定义一个学生<span class="operator">-</span>课程模式S<span class="operator">-</span>T</span><br></pre></td></tr></table></figure><p>实际上是定义了一个命名空间，在这个命名空间里可以进一步定义该模式包含的数据库对象，例如基本表，视图，索引等</p><p>如果没有指定模式名，那么模式名隐含为用户名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> schema &quot;S-T&quot; <span class="operator">&lt;</span>cascade <span class="operator">|</span> restrict<span class="operator">&gt;</span></span><br><span class="line">#cascade 和 restrict必选一个</span><br><span class="line">#cascade的话,则会把这个模式下的所有数据库对象均删除</span><br><span class="line">#restrict的话,如果已经在这个模式下定义了对象,则会拒绝删除</span><br></pre></td></tr></table></figure><h3 id="3-3-2-基本表的定义、删除与修改"><a href="#3-3-2-基本表的定义、删除与修改" class="headerlink" title="3.3.2 基本表的定义、删除与修改"></a>3.3.2 基本表的定义、删除与修改</h3><p>1. 定义基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(sno <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">primary</span>, sname <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">unique</span>, <span class="keyword">foreign</span> key(Cno) <span class="keyword">references</span> Course(Cno)); </span><br><span class="line">#跟在列名后面的是列级完整性约束 单独定义的是表级   </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(<span class="keyword">primary</span> key(Sno, Cno), Cno <span class="type">char</span>(<span class="number">4</span>), Sno <span class="type">char</span>(<span class="number">3</span>), grade <span class="type">smallint</span>); </span><br><span class="line">#如果完整性约束条件涉及多个属性列，则必须定义在表级，如上所示</span><br></pre></td></tr></table></figure><p>2. 数据类型</p><p>3. 模式与表</p><p><strong>4. 修改基本表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 删除列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">column</span> 属性名 cascade<span class="operator">/</span>restrict   #<span class="keyword">column</span>是列的意思注：后面的条件可不写，默认restrict；</span><br><span class="line">#restrict是指删除是有条件的，所删除的属性不能被其他表的约束所引用，不能有视图、触发器、存储过程或函数</span><br><span class="line">#cascade是指删除没有条件，删除的同时，所有相关的对象都将删除 </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 增加列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> (<span class="keyword">column</span>) 属性名 数据类型 (约束条件);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> (<span class="keyword">column</span>) Sname <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 修改列的数据类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify (<span class="keyword">column</span>) 属性名 数据类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score modify id <span class="type">char</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 修改列名(也可以修改数据类型)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score change 原属性名 新属性名 数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score change id <span class="keyword">identity</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">#主码好像改不了</span><br><span class="line">#外码似乎也是<span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 原列名 现列名 数据类型;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> score <span class="operator">&lt;</span>restrict <span class="operator">|</span> cascade<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 删除列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 属性名;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score <span class="keyword">drop</span> score;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 改表名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score rename <span class="keyword">to</span> new_score;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 删除主键约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 增加主键约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> <span class="keyword">primary</span> key(sno);#注意：mysql一张表里只能有一个主键 </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 设置唯一性约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> <span class="keyword">unique</span>（sname）;<span class="operator">/</span><span class="operator">/</span>注意：主键本身就是唯一的 </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>设置外键约束（注意外键一定要是所参考的表（student）的主键，不然报错）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student_course <span class="keyword">add</span> <span class="keyword">foreign</span> key(sno) <span class="keyword">references</span> student(sno);</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 元组上的约束条件 P164</span><br><span class="line">#检查约束<span class="keyword">check</span>(mysql不支持检查约束，但写上不会报错)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student_course <span class="keyword">add</span> <span class="keyword">constraint</span> <span class="keyword">check</span>(score <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">and</span> score <span class="operator">&lt;=</span> <span class="number">100</span>); </span><br><span class="line">#创建的时候就创建<span class="keyword">check</span>语句</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    sno <span class="type">char</span>(<span class="number">9</span>) <span class="keyword">primary</span> key,</span><br><span class="line">        sname <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">        ssex <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">check</span>(ssex <span class="keyword">in</span> (<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>)),</span><br><span class="line">        sage <span class="type">smallint</span>,</span><br><span class="line">        sdept <span class="type">char</span>(<span class="number">20</span>);</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span> 设置默认约束<span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 原列名 现列名 数据类型 <span class="keyword">default</span> 默认值</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student change entime entime <span class="type">date</span> <span class="keyword">default</span> <span class="string">&#x27;2002-09-01&#x27;</span>; </span><br></pre></td></tr></table></figure><h3 id="3-3-3-索引的建立与删除"><a href="#3-3-3-索引的建立与删除" class="headerlink" title="3.3.3 索引的建立与删除"></a>3.3.3 索引的建立与删除</h3><h2 id="3-4-数据查询"><a href="#3-4-数据查询" class="headerlink" title="3.4 数据查询"></a>3.4 数据查询</h2><p>数据查询是数据库的核心操作</p><h3 id="3-4-1-单表查询"><a href="#3-4-1-单表查询" class="headerlink" title="3.4.1 单表查询"></a>3.4.1 单表查询</h3><p>1. 选择表中的若干列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 查询指定列select 属性列,属性列,··· from 表名;<span class="comment">//各列的顺序可以和原表不一样2. 查询所有列select * from 表名;3. 查询经过计算的值select Sname,2014-Sage from 表名; 属性列还可以是算术表达式、字符串常量、函数等。如：select sname,&#x27;year of birth&#x27;,2014-sage,LOWER(sdept) from student;//小写字母表示系名 还可以通过指定别名来改变查询结果的列标题，例如有些含有算术表达式、函数、常量的列名就可指定别名如：select sname NAME,&#x27;yaer of birth&#x27; BIRTH,2014-sage BIRTHDAY from student;</span></span><br></pre></td></tr></table></figure><p>2. 选择表中的若干元组（行）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 消除取值重复的行（两个不相同的元组投影到指定列后，可能会变成相同的行）使用distinct消除:select distinct sno from sc; <span class="number">2.</span> 查询满足条件的元组     a. 比较大小    b. 确定范围    c. 确定集合    d. 字符匹配        select * from student where Sno like <span class="string">&#x27;12313&#x27;</span>;<span class="comment">//like等价于=        //如果like后面的匹配串中不含通配符(%和_)，则可用=取代like，用!=或&lt;&gt;取代not like        select * from student where Sname like &#x27;刘%&#x27;;//有通配符必须用like        //通配符%代表任意长度（包括0）的字符串，_表示任意单个字符        select * from student where Sname like &#x27;欧阳_&#x27;;        select * from student where Sname like &#x27;_阳%&#x27;;//第二个字为阳的        select * from student where Sname not like &#x27;杨%&#x27;;                //如果要查询的字符串本身有通配符，要用escape转义符        select Cno,Credit from Course where Cname like &#x27;DB\_Design&#x27; escape&#x27;\&#x27;;        //escape\表示\为换码字符，这样跟在\后面的字符不再具有通配符的含义    e. 涉及空值的查询    f. 多重条件查询</span></span><br></pre></td></tr></table></figure><p>3. order by 子句（排序用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select Sno,Grade from SC where Cno = <span class="string">&#x27;3&#x27;</span> order by Grade desc;desc: 降序asc: 升序</span><br></pre></td></tr></table></figure><p>4. 聚集函数</p><blockquote><ol><li> count(*)//统计元组个数</li><li> count(distinct 列名)//统计一列中值的个数，取消重复值</li><li> sum(distinct 列名)//计算一列值的总和</li><li> max(distinct 列名)//计算一列中的最大值</li><li> avg(列名)//平均值</li></ol><p>当聚集函数遇到空值时，除count(*)，都跳过空值</p><p>where 子句中不能用聚集函数</p></blockquote><p>5. group by子句（分组用）</p><blockquote><p>将查询结果按某一列或多列的值分组，值相等的一组</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>求各个课程号及相应的选课人数select Cno,count(Sno) from sc group by Cno;  如果分组后还要筛选，用having语句select Cno,count(Sno) from sc group by Cnohaving count(*) &gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure><blockquote><p>where语句和having语句的区别：</p><p>where语句不能用聚集函数，作用于基本表或视图；having短语作用于组，也就是group</p></blockquote><h3 id="3-4-2-连接查询"><a href="#3-4-2-连接查询" class="headerlink" title="3.4.2 连接查询"></a>3.4.2 连接查询</h3><p>1. 等值与非等值连接查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select stu.sno, snamefrom stu,scwhere stu.sno = sc.sno and sc.cno&#x27;2&#x27;; //sno在两个表都有，所以要加前缀</span><br></pre></td></tr></table></figure><p>2. 自身连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询每一门课的间接先修课（先修课的先修课）</span><br></pre></td></tr></table></figure><p>3. 外连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左外连接select student.sno, sname, ssex, sage, sdept, cno, gradefrom student LEFT OUTER JOIN SC ON (student.sno = sc.sno);</span><br></pre></td></tr></table></figure><p>4**. 多表连接**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询每个学生的学号、姓名、选修的课程名、成绩select student.sno, Sname, Cname, Gradefrom student, sc, coursewhere student.sno = sc.sno AND sc.cno = course.cno;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-嵌套查询（nested-query）凸显结构化"><a href="#3-4-3-嵌套查询（nested-query）凸显结构化" class="headerlink" title="3.4.3 嵌套查询（nested query）凸显结构化"></a>3.4.3 嵌套查询（nested query）凸显结构化</h3><blockquote><p>子查询的select语句不能用order by子句，order by只能对最终查询结果排序</p></blockquote><p>1. <strong>带有IN谓词的子查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询和刘成在同一个系学习的学生SELECT sname,sno,sdept FROM student WHERE sdept IN (select sdept from student where sname = &#x27;刘成&#x27;);  在此例中，IN可以用=替换</span><br></pre></td></tr></table></figure><p>子查询的条件不依赖与父查询，称不相关子查询(相关子查询（相关嵌套查询）反之)</p><p><strong>2. 带有比较运算符的子查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找出每个学生超过他自己选秀课程平均成绩的课程号 SELECT Sno,Cno FROM SC xWHERE Grade &gt;= (SELECT AVG(Grade)                FROM                WHERE y.Sno = x.Sno);</span><br></pre></td></tr></table></figure><p><strong>3.带有any（some）或all谓词的子查询</strong></p><p><strong>4. 带有exists谓词的子查询</strong></p><h3 id="3-4-4-集合查询"><a href="#3-4-4-集合查询" class="headerlink" title="3.4.4 集合查询"></a>3.4.4 集合查询</h3><h3 id="3-4-5-基于派生表的查询"><a href="#3-4-5-基于派生表的查询" class="headerlink" title="3.4.5 基于派生表的查询"></a>3.4.5 基于派生表的查询</h3><h3 id="3-4-6-select语句的一般格式"><a href="#3-4-6-select语句的一般格式" class="headerlink" title="3.4.6 select语句的一般格式"></a>3.4.6 select语句的一般格式</h3><h2 id="3-5-数据更新"><a href="#3-5-数据更新" class="headerlink" title="3.5 数据更新"></a>3.5 数据更新</h2><h3 id="3-5-1-插入数据"><a href="#3-5-1-插入数据" class="headerlink" title="3.5.1 插入数据"></a>3.5.1 插入数据</h3><p><strong>1. 插入元组</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">insert</span>语句插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score <span class="keyword">values</span>(<span class="number">19421100</span> , 李源);#<span class="keyword">insert</span>这种简写的方式虽然非常简单,但是<span class="keyword">Values</span>后面的值必须和表中的类顺序对应,</span><br><span class="line"> #且类型要保持一直,即使表中某一个列不需要值也必须赋值为<span class="keyword">null</span>,比如我们的主键id设置的是递增实际上是不用设置值的,但是使用这种方式必须赋值为<span class="keyword">null</span></span><br><span class="line"> </span><br><span class="line">#<span class="keyword">insert</span>语句完整写法</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score(id , name) <span class="keyword">values</span>(<span class="number">19429999</span> ， &quot;李源&quot;);#没有出现的属性列，自动取空值</span><br><span class="line"></span><br><span class="line">#<span class="keyword">insert</span> <span class="keyword">into</span>批量插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score(id , name) <span class="keyword">values</span>(<span class="number">19429897</span> , &quot;a&quot;) , <span class="keyword">values</span>(<span class="number">1942055555</span>  , &quot;罗林&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#replace <span class="keyword">insert</span>语句</span><br><span class="line">replace <span class="keyword">into</span> score(id , name) <span class="keyword">values</span>(<span class="number">19420108</span> , &quot;贺钰淇&quot;);#此语句的作用是当我们在插入一条数据时，如果此条已经存在，那么先删除原来存在的数据再添加插入的数据，如果不存在那么直接插入新的数据。注意：区分是否存在是通过主键来确定的</span><br><span class="line"></span><br><span class="line">#<span class="keyword">insert</span> ignore <span class="keyword">into</span>语句</span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> student(id , name) <span class="keyword">values</span>(<span class="number">19420336</span> , &quot;你好&quot;);#由于原来存在，所以不会更改、</span><br></pre></td></tr></table></figure><p><strong>2. <strong>插</strong>入子查询结果</strong></p><blockquote><p>子查询既可以嵌套在select语句中，也可以用在insert语句中用以生成要插入的数据</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">insert</span> <span class="keyword">select</span> 语句</span><br><span class="line">#<span class="number">1.</span>此语句的作用是将<span class="keyword">SELECT</span>语句的结果插入表中,可实现数据迁移</span><br><span class="line">#<span class="number">2.</span>语法:<span class="keyword">insert</span> <span class="keyword">into</span> 插入的表名(字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3</span>) <span class="keyword">select</span> 被查询的字段<span class="number">1</span>,被查询的字段<span class="number">2</span> <span class="keyword">from</span> 被查询的表名;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name , age ,classid)<span class="keyword">select</span> name ,age , sex <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_age(Sdept,avg_age) <span class="keyword">select</span> sedpt , <span class="built_in">avg</span>(Sage) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> sdept;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5-2-修改数据"><a href="#3-5-2-修改数据" class="headerlink" title="3.5.2 修改数据"></a>3.5.2 修改数据</h3><p>1. 修改某一个元组的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update 表名 <span class="keyword">set</span> 属性名 <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">where</span> 属性名 <span class="operator">=</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">update student <span class="keyword">set</span> Sage <span class="operator">=</span> <span class="number">16</span> <span class="keyword">where</span> Sno <span class="operator">=</span> <span class="string">&#x27;201215121&#x27;</span>；</span><br></pre></td></tr></table></figure><p>2. 修改多个元组的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update student <span class="keyword">set</span> Sage <span class="operator">=</span> Sage <span class="operator">+</span> <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>3. 带子查询的修改语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update sc</span><br><span class="line"><span class="keyword">set</span> grade <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">in</span> (<span class="keyword">select</span> sno <span class="keyword">from</span> student  <span class="keyword">where</span> sdept <span class="operator">=</span> &quot;CS&quot;)</span><br></pre></td></tr></table></figure><h3 id="3-5-3-删除数据"><a href="#3-5-3-删除数据" class="headerlink" title="3.5.3 删除数据"></a>3.5.3 删除数据</h3><p><em>一本书，delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了</em><br>truncate是清空表的数据，效率远高于delete。<br>delete关键字 ：只删除数据不删除表的结构。</p><p>1. 删除一个元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 属性名 <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> (limit <span class="number">10</span>)#就删除<span class="number">10</span>条</span><br></pre></td></tr></table></figure><p>2. 删除多个元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名；#删除所有，该表成为空表</span><br></pre></td></tr></table></figure><p>3. 带子查询的删除语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC <span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno <span class="keyword">from</span> stu <span class="keyword">where</span> Sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="3-6-空值的处理"><a href="#3-6-空值的处理" class="headerlink" title="3.6 空值的处理"></a>3.6 空值的处理</h2><p><code>is null </code>和<code>is not null</code>来表示控制</p><p>空值与另一个值的算术运算的结果是空值</p><p>空值与另一个值的比较运算的结果是<code>UNKNOWN</code></p><p>在查询语句中，只有where和having字句中选择的条件为true的元组才会被选出来作为输出结果</p><h2 id="3-7-视图"><a href="#3-7-视图" class="headerlink" title="3.7 视图"></a>3.7 视图</h2><h3 id="3-7-1-定义视图"><a href="#3-7-1-定义视图" class="headerlink" title="3.7.1 定义视图"></a>3.7.1 定义视图</h3><p>1. 建立视图</p><blockquote><p>只是把视图的定义放到数据字典中，而不是执行其中的select语句</p><p>组成视图的列名要么全部省略，要么全部指定</p><p>以下三种情况必须全部指定：</p><ol><li> 某个目标列是函数表达式</li><li> 有同名列</li><li> 需要更合适的名字</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> IS_student(sno,sname,sage) <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> sno,sname,sage</span><br><span class="line"><span class="keyword">from</span> studentwhere sdept <span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>with check option 表示对视图操作时要满足视图定义中的条件(比如下例中的sdept=’IS‘)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">with</span> <span class="keyword">check</span> option条件</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> IS_Student</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> Sno , Sname , Sage</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sdept <span class="operator">=</span> &quot;IS&quot;</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> option          #之后对该视图进行插入、修改和删除操作时，关系数据库系统会自动加上Sdept <span class="operator">=</span> &quot;IS&quot;的条件</span><br></pre></td></tr></table></figure><blockquote><p>若一个视图是从单个基本表导出，且只去掉了某些行列，但保留了主码，称这类视图为行列子集视图</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#建立选修了信息系统<span class="number">1</span>号课程的学生的视图(学号，姓名，成绩)</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">view</span> IS_S1(sno , sname , grade)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> sno , sname , grade</span><br><span class="line"><span class="keyword">from</span> student , sc</span><br><span class="line"><span class="keyword">where</span> sdept <span class="operator">=</span> &quot;IS&quot; <span class="keyword">and</span></span><br><span class="line">student.sno <span class="operator">=</span> sc.sno <span class="keyword">and</span> sc.cno <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>带虚拟列（派生属性，在基本表中不存在）的视图称为带表达式的视图</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#带虚拟列的视图（带表达式的视图）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> bt_s(sno , sname , sbirth)</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> sno , sname , <span class="number">2014</span><span class="operator">-</span>sage</span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure><blockquote><p>带有聚集函数和group by 子句的查询来定义的视图称为分组视图</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#分组视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> s_G(sno , Gvag)</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> sno , <span class="built_in">avg</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure><blockquote><p>建立视图上的视图</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#建立在视图上的视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> IS_S2</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> sno , sname , grade</span><br><span class="line"><span class="keyword">from</span> IS_S1</span><br><span class="line"><span class="keyword">where</span> grade <span class="operator">&gt;=</span> <span class="number">90</span></span><br></pre></td></tr></table></figure><blockquote><p>保持逻辑独立性</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> F_Student(F_Snoo , name ,sex,age,dept)</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">where</span> ssex <span class="operator">=</span> &quot;女&quot;</span><br><span class="line">#保持逻辑独立性：比如把上述age的基类改成birthday ， 如何保持逻辑独立性</span><br></pre></td></tr></table></figure><p>2. 删除视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view IS_stu cascade;</span><br></pre></td></tr></table></figure><blockquote><p>cascade表示把由该视图导出的所有视图都删除</p><p>当基本表删除或者改变基本表的结构后，基本表和视图之间的镜像关系就会被破坏，该视图就不能正常使用了。为了避免这种情况，必须用删除视图语句显式删除，然后重构这个视图</p></blockquote><h3 id="3-7-2-查询视图"><a href="#3-7-2-查询视图" class="headerlink" title="3.7.2 查询视图"></a>3.7.2 查询视图</h3><blockquote><p>视图消解：把视图的查询转换为对基本表的查询。有效性检查（是否存在），从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询。</p></blockquote><h3 id="3-7-3-更新视图"><a href="#3-7-3-更新视图" class="headerlink" title="3.7.3 更新视图"></a>3.7.3 更新视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#对视图的更新最重要转换成对基本表的更新。如果在增删改时，有意对不属于视图范围内的基本表数据进行操作，可以定义视图时家上加<span class="keyword">with</span> <span class="keyword">check</span> option字句。这样在对视图增删改时，关系数据库管理系统会检查视图定义中的条件，若不满足条件就拒绝执行操作</span><br><span class="line">update IS_Student <span class="keyword">set</span> sname <span class="operator">=</span> &quot;刘晨&quot; <span class="keyword">where</span> sno <span class="operator">=</span> &quot;202115122&quot;</span><br><span class="line">转换成</span><br><span class="line">update student <span class="keyword">set</span> sname <span class="operator">=</span>&quot;刘晨&quot; <span class="keyword">where</span> sno <span class="operator">=</span> &quot;202115122&quot; <span class="keyword">and</span> sdept<span class="operator">=</span>&quot;IS&quot;</span><br><span class="line">#视图更新的时候如果没有意义则无法执行</span><br></pre></td></tr></table></figure><h3 id="3-7-4-视图的作用"><a href="#3-7-4-视图的作用" class="headerlink" title="3.7.4 视图的作用"></a>3.7.4 视图的作用</h3><h1 id="第4章-数据库安全性"><a href="#第4章-数据库安全性" class="headerlink" title="第4章 数据库安全性"></a>第4章 数据库安全性</h1><h2 id="4-2-DB安全性控制"><a href="#4-2-DB安全性控制" class="headerlink" title="4.2 DB安全性控制"></a>4.2 DB安全性控制</h2><h3 id="4-2-1-用户身份鉴别"><a href="#4-2-1-用户身份鉴别" class="headerlink" title="4.2.1 用户身份鉴别"></a>4.2.1 用户身份鉴别</h3><ol><li> 静态口令鉴别   密码</li><li> 动态口令鉴别   每次鉴别时都需使用动态产生的新口令登陆</li><li> 生物特征鉴别</li><li> 智能卡鉴别</li></ol><h3 id="4-2-2-存取控制"><a href="#4-2-2-存取控制" class="headerlink" title="4.2.2 存取控制"></a>4.2.2 存取控制</h3><ol><li> 自主存取控制 : 用户可以”自主”地决定将数据的存取权授予何人、决定是否也将“授权”的权限授予别人。</li><li> 强制存取控制  每个数据库对象被标以一定的密级</li></ol><h3 id="4-2-3-自主存取控制方法"><a href="#4-2-3-自主存取控制方法" class="headerlink" title="4.2.3 自主存取控制方法"></a>4.2.3 自主存取控制方法</h3><blockquote><p>用户权限由 数据库对象和操作类型 组成</p></blockquote><h3 id="4-2-4-授权：授予与收回"><a href="#4-2-4-授权：授予与收回" class="headerlink" title="4.2.4 授权：授予与收回"></a>4.2.4 授权：授予与收回</h3><p><strong>1. grant</strong></p><blockquote><p>一些权限：</p><p>基本表和视图：select, insert, update, delete references, all privileges</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> student <span class="keyword">to</span> u1 <span class="keyword">with</span> <span class="keyword">grant</span> option#可以把这个权限再次授予其他用户</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="keyword">table</span> student,course <span class="keyword">to</span> u2,u3</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> stu <span class="keyword">to</span> public#表示全体用户</span><br><span class="line"><span class="keyword">grant</span> update(Sno),<span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> stu <span class="keyword">to</span> u4;</span><br></pre></td></tr></table></figure><p><strong>2. revoke</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> update(Sno) <span class="keyword">on</span> <span class="keyword">table</span> stu <span class="keyword">from</span> u4</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> sc <span class="keyword">from</span> public</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">insert</span> <span class="keyword">on</span> <span class="keyword">table</span> sc <span class="keyword">from</span> u5 cascade</span><br></pre></td></tr></table></figure><h3 id="4-2-5-创建数据库模式的权限"><a href="#4-2-5-创建数据库模式的权限" class="headerlink" title="4.2.5 创建数据库模式的权限"></a>4.2.5 创建数据库模式的权限</h3><p>对数据库模式一类的数据库对象的授权由数据库管理员在创建用户的时候实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &lt;username&gt; [with] [DBA|RESOURCE|CONNECT];</span><br></pre></td></tr></table></figure><table><thead><tr><th>拥有的权限</th><th>create user</th><th>create schema</th><th>create table</th><th>登录数据库,执行数据查询和操控</th></tr></thead><tbody><tr><td>DBA</td><td>可以</td><td>可以</td><td>可以</td><td>可以</td></tr><tr><td>RESOURCE</td><td>不可以</td><td>不可以</td><td>可以</td><td>可以</td></tr><tr><td>CONNECT</td><td>不可以</td><td>不可以</td><td>不可以</td><td>可以，但必须有相关的权限</td></tr></tbody></table><h3 id="4-2-6-数据库角色"><a href="#4-2-6-数据库角色" class="headerlink" title="4.2.6 数据库角色"></a>4.2.6 数据库角色</h3><p>数据库角色是被病名的一组与数据库操作相关的权限，角色是权限的集合。因此可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限，可以简化授权的过程。</p><p><em>通过角色来实现将一组权限授予一个用户</em></p><ol><li><p>创建一个角色R1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role R1</span><br></pre></td></tr></table></figure></li><li><p>使用grant语句,使角色R1拥有Student表的select、update、insert权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> , update , <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">table</span> student</span><br><span class="line"><span class="keyword">to</span> R1</span><br></pre></td></tr></table></figure></li><li><p>将这个角色授予a , b , c</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> R1</span><br><span class="line"><span class="keyword">to</span> a , b , c</span><br></pre></td></tr></table></figure></li><li><p>一次性通过R1来回收a的这三个权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> R1</span><br><span class="line"><span class="keyword">from</span> a</span><br></pre></td></tr></table></figure></li></ol><p><em>角色的权限修改和删除</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">delete</span> <span class="keyword">on</span> <span class="keyword">table</span> student <span class="keyword">to</span> R1</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> student <span class="keyword">from</span> R1</span><br></pre></td></tr></table></figure><h3 id="强制存取控制方法"><a href="#强制存取控制方法" class="headerlink" title="强制存取控制方法"></a>强制存取控制方法</h3><h2 id="4-3-视图机制"><a href="#4-3-视图机制" class="headerlink" title="4.3 视图机制"></a>4.3 视图机制</h2><h2 id="4-4-审计"><a href="#4-4-审计" class="headerlink" title="4.4 审计"></a>4.4 审计</h2><h1 id="第5章数据库完整性"><a href="#第5章数据库完整性" class="headerlink" title="第5章数据库完整性"></a>第5章数据库完整性</h1><h2 id="5-1实体完整性"><a href="#5-1实体完整性" class="headerlink" title="5.1实体完整性"></a>5.1实体完整性</h2><ol><li>列级完整性</li><li>表级完整性</li><li>只能在表级定义的完整性</li></ol><h2 id="5-2参照完整性"><a href="#5-2参照完整性" class="headerlink" title="5.2参照完整性"></a>5.2参照完整性</h2><h3 id="5-2-1参照完整性定义"><a href="#5-2-1参照完整性定义" class="headerlink" title="5.2.1参照完整性定义"></a>5.2.1参照完整性定义</h3><h3 id="5-2-2参照完整性检查和违约处理"><a href="#5-2-2参照完整性检查和违约处理" class="headerlink" title="5.2.2参照完整性检查和违约处理"></a>5.2.2参照完整性检查和违约处理</h3><table><thead><tr><th>被参照表</th><th>参照表</th><th>违约处理</th></tr></thead><tbody><tr><td>可能破坏参照完整性</td><td>插入元组</td><td>拒绝</td></tr><tr><td>可能破坏参照完整性</td><td>修改外码值</td><td>拒绝</td></tr><tr><td>修改元祖</td><td>可能破坏参照完整性</td><td>拒绝(默认)/级联删除/设为空值</td></tr><tr><td>修改主码值</td><td>可能破坏参照完整性</td><td>拒绝(默认)/级联删除/设为空值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(</span><br><span class="line">sno <span class="type">char</span>(<span class="number">9</span>),</span><br><span class="line">    cno <span class="type">char</span>(<span class="number">9</span>),</span><br><span class="line">    grade <span class="type">smallint</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(sno , cno),#表级实体完整性约束</span><br><span class="line">    <span class="keyword">foreign</span> key (sno) <span class="keyword">references</span> Student(sno)</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">delete</span> cascade#当修改Student表中的元组时,级联删除SC表中相应的元组</span><br><span class="line">    <span class="keyword">on</span> update cascade#当更新Student表中的sno时,级联更新SC表中相应的元组</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="5-3-用户定义的完整性"><a href="#5-3-用户定义的完整性" class="headerlink" title="5.3 用户定义的完整性"></a>5.3 用户定义的完整性</h2><h3 id="5-3-1-属性上的约束条件-P163"><a href="#5-3-1-属性上的约束条件-P163" class="headerlink" title="5.3.1 属性上的约束条件(P163)"></a>5.3.1 属性上的约束条件(P163)</h3><p>1. 属性上约束条件的定义</p><blockquote><p>包括：</p><p>1. not null</p><p>2. unique</p><p>3. check</p></blockquote><h3 id="5-3-2-元组上的约束条件的定义"><a href="#5-3-2-元组上的约束条件的定义" class="headerlink" title="5.3.2 元组上的约束条件的定义"></a>5.3.2 元组上的约束条件的定义</h3><p>在创建表时可用check短语定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    sno <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">primary</span>, </span><br><span class="line">    sname <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">unique</span>, </span><br><span class="line">    sex <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">foreign</span> key(Cno) <span class="keyword">references</span> Course(Cno),<span class="keyword">check</span>(sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">OR</span> Sname <span class="keyword">not</span> <span class="keyword">like</span><span class="string">&#x27;Ms.%&#x27;</span>)); #男性名字不能以Ms.开头</span><br></pre></td></tr></table></figure><h2 id="5-4-完整性约束命名字句"><a href="#5-4-完整性约束命名字句" class="headerlink" title="5.4 完整性约束命名字句"></a>5.4 完整性约束命名字句</h2><h2 id="5-5-域中的完整性限制"><a href="#5-5-域中的完整性限制" class="headerlink" title="5.5 域中的完整性限制"></a>5.5 域中的完整性限制</h2><h2 id="5-6-断言"><a href="#5-6-断言" class="headerlink" title="5.6 断言"></a>5.6 断言</h2><h2 id="5-7-触发器"><a href="#5-7-触发器" class="headerlink" title="5.7 触发器"></a>5.7 触发器</h2><h1 id="第六章-关系数据库理论"><a href="#第六章-关系数据库理论" class="headerlink" title="第六章 关系数据库理论"></a>第六章 关系数据库理论</h1><h2 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a>6.2 规范化</h2><h3 id="6-2-1函数依赖"><a href="#6-2-1函数依赖" class="headerlink" title="6.2.1函数依赖"></a>6.2.1函数依赖</h3><ol><li><p>非平凡的函数依赖</p></li><li><p>平凡的函数依赖(自成立)</p></li><li><p>完全函数依赖 : </p><p>设有关系模式R(U)，U是属性集，X和Y是U的子集，如果X→Y是一个函数依赖，且对X的任何一个真子集X’都不存在X’→Y，则称X→Y是一个完全函数依赖(Full Functional Dependency)，即Y完全函数依赖于X</p><p>即在一张表中字段分为 X 和 Y 两个集合，X集合数据唯一确定一条数据 Y ，X集合字段中的任何一个字段都不能确定唯一一条数据 Y ，就称 Y 完全函数依赖于 X</p></li><li><p>部分函数依赖 : </p><p>设有关系模式R(U)，U是属性集，X和Y是U的子集，如果X→Y是一个函数依赖，且对X的任何一个真子集X’都存在X’→Y，则称X→Y是一个部分函数依赖(Full Functional Dependency)，即Y部分函数依赖于X</p><p>即在一张表中分为 X 和 Y 集合，X集合数据唯一确定一条数据Y，并且X中任意字段或组合字段都可以唯一确定Y集合数据，则称 Y 部分函数依赖于 X</p></li><li><p>传递函数依赖 : </p><p>在关系模式R(U)中，设X，Y，Z是U的不同的属性子集，如果X确定Y、Y确定Z，且有X不包含Y，Y不确定X，（X∪Y）∩Z=空集合，则称Z传递函数依赖(transitive functional dependency) 于X</p><p>即在一张表中，字段分为 X、Y、Z，如果X可以决定Y，Y决定Z，但是Y不能决定X，则称Z传递函数依赖于X</p></li></ol><h3 id="6-2-3范式"><a href="#6-2-3范式" class="headerlink" title="6.2.3范式"></a>6.2.3范式</h3><p>第一范式:每个属性不可以再分</p><p>第二范式:消除了非主属性对码的部分函数依赖</p><p>第三范式:消除了非主属性对码的传递函数依赖.(主码:SNO , 主属性:SNO , 非主属性:SNAME, SDEPT,系主任.  SNO-&gt;SDEPT  , SDEPT-&gt;系主任)</p><p>BCNF范式:消除了主属性对码的部分函数依赖和传递函数依赖</p><h3 id="6-2-4多值依赖"><a href="#6-2-4多值依赖" class="headerlink" title="6.2.4多值依赖"></a>6.2.4多值依赖</h3><h2 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a>6.3 数据依赖的公理系统</h2><h3 id="6-3-1Armstrong公理系统"><a href="#6-3-1Armstrong公理系统" class="headerlink" title="6.3.1Armstrong公理系统"></a>6.3.1Armstrong公理系统</h3><p>自反律:若Y⊆X⊆U，则X-&gt;Y为F所蕴涵</p><p>增广律:若X-&gt;Y为F所蕴涵，且Z⊆U，则XZ-&gt;YZ为F所蕴涵</p><p>传递律:若X-&gt;Y,Y-&gt;Z为F所蕴涵，则X-&gt;Z为F所蕴涵</p><p>合并规则:若X→Y，X→Z同时在R上成立，则X→YZ在R上也成立。</p><p>伪传递规则:若X→Y在R上成立，且WY→Z，则XW→Z。</p><p>分解规则:若X→W在R上成立，且属性集Z包含于W，则X→Z在R上也成立。</p><h3 id="6-3-2闭包-属性闭包的计算算法"><a href="#6-3-2闭包-属性闭包的计算算法" class="headerlink" title="6.3.2闭包:属性闭包的计算算法"></a>6.3.2闭包:属性闭包的计算算法</h3><p><img src="C:/Users/%E6%9D%8E%E6%BA%90/AppData/Roaming/Typora/typora-user-images/image-20211204165353319.png" alt="image-20211204165353319"></p><h3 id="6-3-3覆盖"><a href="#6-3-3覆盖" class="headerlink" title="6.3.3覆盖"></a>6.3.3覆盖</h3><h2 id="6-4模式的分解"><a href="#6-4模式的分解" class="headerlink" title="6.4模式的分解"></a>6.4模式的分解</h2><p><a href="https://www.cnblogs.com/guanghe/p/14788762.html">博客园</a></p><h1 id="第7章-数据库设计P205"><a href="#第7章-数据库设计P205" class="headerlink" title="第7章 数据库设计P205"></a>第7章 数据库设计P205</h1><h2 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h2><p>数据库设计是指对于一个给定的应用环境，构造设计优化的数据库<strong>逻辑模式</strong>和<strong>物理结构</strong>，并据此建立<strong>数据库</strong>及其<strong>应用系统</strong>，使之能够有效的存储和管理数据，满足用户的应用需求，包括信息管理要求和数据操作要求。</p><h2 id="7-1-1-数据库设计的特点"><a href="#7-1-1-数据库设计的特点" class="headerlink" title="#7.1.1 数据库设计的特点"></a>#7.1.1 数据库设计的特点</h2><blockquote><p>1. “三分技术，七分管理，十二分基础数据”<br>2. 结构（数据）设计和行为（处理）设计相结合</p></blockquote><h3 id="7-1-3-数据库设计基本步骤"><a href="#7-1-3-数据库设计基本步骤" class="headerlink" title="7.1.3 数据库设计基本步骤"></a>7.1.3 数据库设计基本步骤</h3><blockquote><p>需求分析、概念结构设计、逻辑结构设计、数据库物理结构设计、数据库实施、数据库运行和维护</p></blockquote><p>1 . 需求分析</p><ul><li>准确了解与分析总体、核心业务及其信息需求（包括数据与处理）</li></ul><p>2 . 概念结构设计:</p><ul><li>通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型</li></ul><p>3 . 逻辑结构设计:</p><ul><li>将概念结构转换为某个DBMS所支持的数据模型</li><li>对其进行优化</li></ul><p>4 . 数据库物理结构设计:</p><ul><li>为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）</li></ul><p>5 . 数据库实施:</p><ul><li>根据逻辑设计和物理设计的结果，运用DBMS提供的数据库语言（如SQL）及宿主语言<ul><li>建立数据库</li><li>编制与调试应用程序</li><li>组织数据入库</li><li>进行试运行</li></ul></li></ul><p>6 . 数据库运行和维护:</p><ul><li>数据库应用系统经过试运行后即可投入正式运行</li><li>在数据库系统运行过程中必须不断地对其进行评价、调整与修改</li></ul><h2 id="7-3-概念结构设计"><a href="#7-3-概念结构设计" class="headerlink" title="7.3 概念结构设计"></a>7.3 概念结构设计</h2><h3 id="7-3-1概念模型"><a href="#7-3-1概念模型" class="headerlink" title="7.3.1概念模型"></a>7.3.1概念模型</h3><p>概念模型的主要特点是：</p><pre><code>1. 真实充分地反映现实世界2. 易于理解3. 易于更改4. 易于向关系、网状、层次等各种数据模型转换</code></pre><h3 id="7-3-2E-R模型"><a href="#7-3-2E-R模型" class="headerlink" title="7.3.2E-R模型"></a>7.3.2E-R模型</h3><ul><li>实体之间的联系</li></ul><ol><li><p>两个实体型之间的联系</p><p>（1）一对一联系<br>（2）一对多联系<br>（3）多对多联系</p></li><li><p>两个以上的实体型之间的联系：同上</p></li><li><p>单个实体型内的联系</p></li></ol><ul><li>一般地，把参与联系的实体型的数目称为联系的度。N个实体型之间的联系度为N，也称为N元联系。</li></ul><h3 id="7-3-5概念结构设计-实体与属性的划分原则-E-R图集成"><a href="#7-3-5概念结构设计-实体与属性的划分原则-E-R图集成" class="headerlink" title="7.3.5概念结构设计-实体与属性的划分原则/E-R图集成"></a>7.3.5概念结构设计-实体与属性的划分原则/E-R图集成</h3><blockquote><h4 id="实体与属性的划分原则"><a href="#实体与属性的划分原则" class="headerlink" title="实体与属性的划分原则:"></a>实体与属性的划分原则:</h4></blockquote><ul><li>属性必须是不可分的数据项；</li><li>联系只发生在实体之间，而不是属性间；</li></ul><blockquote><h4 id="E-R图的集成"><a href="#E-R图的集成" class="headerlink" title="E-R图的集成:"></a>E-R图的集成:</h4></blockquote><p>  ——自顶向下的需求分析</p><p>  ——自底向上的概念设计</p><blockquote><h4 id="集成局部E-R图"><a href="#集成局部E-R图" class="headerlink" title="集成局部E-R图"></a>集成局部E-R图</h4></blockquote><p><strong>1.合并——消除冲突</strong></p><pre><code>•属性冲突:属性域冲突：属性值的类型、取值范围、取值集合不同属性取值单位冲突：斤和公斤•命名冲突:同名异义：不同意义的对象在不同的局部应用中具有相同的名字异名同义：同一意义的对象在不同的局部应用中具有不同的名字•结构冲突:同一对象在不同应用中具有不同的抽象：把职工当作实体或属性同一实体在不同子系统的E-R图所包含的属性个数和属性排列次序不完全相同</code></pre><p><strong>2.修改与重构</strong></p><pre><code>•冗余的数据•冗余的联系</code></pre><h2 id="7-4-逻辑结构设计"><a href="#7-4-逻辑结构设计" class="headerlink" title="7.4 逻辑结构设计"></a>7.4 逻辑结构设计</h2><p>逻辑结构设计的任务就是把概念结构设计好的基本E-R图转换为数据库管理系统所支持的数据模型相符合的逻辑结构。</p><h3 id="7-4-1-E-R图向关系模型的转换"><a href="#7-4-1-E-R图向关系模型的转换" class="headerlink" title="7.4.1 E-R图向关系模型的转换"></a>7.4.1 E-R图向关系模型的转换</h3><p>一个实体型转换成一个关系模式。</p><p>(1) <strong>1:1联系</strong></p><ul><li>转换为一个独立的关系模式</li><li>与某一端实体对应的关系模式合并</li></ul><p>(2) <strong>1:n联系</strong></p><ul><li>转换为一个独立的关系模式</li><li>与n端对应的关系模式合并</li></ul><p>(3)  <strong>m:n联系</strong></p><ul><li>转换为一个关系模式</li></ul><p>(4)  <strong>多元联系</strong></p><ul><li>转换为一个关系模式。</li></ul><p>(5)<strong>具有<u>相同码</u>的关系模式可合并</strong></p><p><strong>合并方法</strong>：将其中一个关系模式的全部属性加入到另一个关系模式中，然后去掉其中的同义属性（可能同名      也可能不同名），并适当调整属性的次序</p><h3 id="7-4-2-数据模型的优化"><a href="#7-4-2-数据模型的优化" class="headerlink" title="7.4.2 数据模型的优化"></a>7.4.2 数据模型的优化</h3><blockquote><p>概念 : 以<strong>规范化理论</strong>为指导，适当地修改、调整数据模型的结构，进一步提高数据库应用系统的<strong>性能</strong>。</p></blockquote><p>1.确定数据依赖</p><p>2.消除冗余联系——进行极小化处理</p><p>3.确定所属范式</p><p>4.基于应用环境，分析并确定确定是否需要对模式进行合并或分解。</p><ul><li><p>  水平分解</p></li><li><p>  垂直分解</p></li></ul><p><strong>注意：</strong>并不是规范化程度越高，关系就越优，一般第三范式就足够。</p><h2 id="7-5-DB的物理设计"><a href="#7-5-DB的物理设计" class="headerlink" title="7.5 DB的物理设计"></a>7.5 DB的物理设计</h2><h3 id="7-5-2关系模式存取方法选择"><a href="#7-5-2关系模式存取方法选择" class="headerlink" title="7.5.2关系模式存取方法选择"></a>7.5.2关系模式存取方法选择</h3><blockquote><h4 id="DBMS常用存取方法"><a href="#DBMS常用存取方法" class="headerlink" title="DBMS常用存取方法"></a>DBMS常用存取方法</h4></blockquote><ul><li><p>索引方法——目前主要是B+树索引</p></li><li><p>聚簇（Cluster）方法 :  把一个或一组属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块的存取方法。</p></li><li><p>HASH方法</p></li></ul><h3 id="7-5-3确定数据库的存储结构"><a href="#7-5-3确定数据库的存储结构" class="headerlink" title="7.5.3确定数据库的存储结构"></a>7.5.3确定数据库的存储结构</h3><blockquote><p>基本原则:</p></blockquote><ul><li><p>易变部分与稳定部分分开存放；</p></li><li><p>存取频率较高部分与存取频率较低部分，分开存放；</p></li></ul><h2 id="7-6-DB的实施和维护"><a href="#7-6-DB的实施和维护" class="headerlink" title="7.6 DB的实施和维护"></a>7.6 DB的实施和维护</h2><h3 id="7-6-1-数据载入和应用程序的调试"><a href="#7-6-1-数据载入和应用程序的调试" class="headerlink" title="7.6.1 数据载入和应用程序的调试"></a>7.6.1 数据载入和应用程序的调试</h3><ul><li>数据装载方法<ul><li>人工方法</li><li>计算机辅助数据入库</li></ul></li><li>应用程序调试与组织数据入库并行进行</li></ul><h1 id="第9章-关系查询处理和查询优化"><a href="#第9章-关系查询处理和查询优化" class="headerlink" title="第9章 关系查询处理和查询优化"></a>第9章 关系查询处理和查询优化</h1><h2 id="9-1-关系DBS的查询处理"><a href="#9-1-关系DBS的查询处理" class="headerlink" title="9.1 关系DBS的查询处理"></a>9.1 关系DBS的查询处理</h2><h3 id="9-1-1查询处理步骤"><a href="#9-1-1查询处理步骤" class="headerlink" title="9.1.1查询处理步骤"></a>9.1.1查询处理步骤</h3><h4 id="1-查询分析"><a href="#1-查询分析" class="headerlink" title="1. 查询分析"></a>1. 查询分析</h4><pre><code> 词法分析、语法分析</code></pre><h4 id="2-查询检查"><a href="#2-查询检查" class="headerlink" title="2. 查询检查"></a>2. 查询检查</h4><pre><code>语义分析、符号名转换、安全性检测、完整性初步检测</code></pre><h4 id="3-查询优化"><a href="#3-查询优化" class="headerlink" title="3. 查询优化"></a>3. 查询优化</h4><pre><code>代数优化(逻辑优化)、物理优化(基于规则、代价、语义)等、生成查询计划树</code></pre><h4 id="4-查询执行"><a href="#4-查询执行" class="headerlink" title="4. 查询执行"></a>4. 查询执行</h4><pre><code>代码生成(自底向上/自顶向下策略)</code></pre><h3 id="9-1-2实现查询操作的算法示例"><a href="#9-1-2实现查询操作的算法示例" class="headerlink" title="9.1.2实现查询操作的算法示例"></a>9.1.2实现查询操作的算法示例</h3><ol><li><p>选择操作的实现：全表扫描/索引扫描</p></li><li><p>连接操作的实现：查询处理中最常用最耗时的操作之一</p><ol><li>嵌套循环算法：最简单最通用，实际上都是基于数据块的循环</li><li>排序-合并算法：常用与等值连接，尤其适合各个表已经排好序的情况。第一步：如果参与连接的表没有排好序，根据连接属性排序第二步：sorted_merge</li><li>索引连接算法：根据表上已经建立好的索引，根据索引查找匹配的元组</li><li>hash join 算法：等值连接，要求内存足够大，小表的hash表要全部能够放进内存。分成两个阶段:<br>​第一步，为小表建立hash表，根据连接属性作为hash码<br>​第二步，对另外一张表的连接属性hash一遍，将匹配的元组连接起来</li></ol></li></ol><h2 id="9-2-关系DBS的查询优化"><a href="#9-2-关系DBS的查询优化" class="headerlink" title="9.2 关系DBS的查询优化"></a>9.2 关系DBS的查询优化</h2><h3 id="9-2-1-查询优化概述"><a href="#9-2-1-查询优化概述" class="headerlink" title="9.2.1 查询优化概述"></a>9.2.1 查询优化概述</h3><blockquote><p>查询优化的优点不仅在于用户不必考虑如何最好的表达查询以获得较高的效率，而且在于系统能比用户程序的“优化”做的更好.</p></blockquote><ol><li><p>在集中式数据库中，查询执行开销主要包括磁盘存取块数（IO代价）、处理机时间（CPU代价）以及查询的内存开销,即:</p><p>总代价=I/O代价+CPU代价+内存代价+通信代价</p></li><li><p>计算查询代价时一般用查询处理读写的块数作为衡量单位</p></li></ol><h2 id="9-3-代数优化"><a href="#9-3-代数优化" class="headerlink" title="9.3 代数优化"></a>9.3 代数优化</h2><h3 id="9-3-1-关系代数表达式等价变换规则"><a href="#9-3-1-关系代数表达式等价变换规则" class="headerlink" title="9.3.1 关系代数表达式等价变换规则"></a>9.3.1 关系代数表达式等价变换规则</h3><p>代数优化策略是通过对关系代数表达式的等价交换来提高查询效率.</p><p>（1）连接、笛卡尔积交换律<br>（2）连接、笛卡尔积的结合律<br>（3）投影的串接定律<br>（4）选择的串接定律<br>（5）选择与投影操作的交换律<br>（6）选择与笛卡尔积的交换律<br>（8） 选择与差运算的分配律<br>（9） 选择对自然连接的分配<br>（10）投影与笛卡尔积的分配律<br>（11）投影与并的分配律</p><h3 id="9-3-2-查询树的启发式优化-重点"><a href="#9-3-2-查询树的启发式优化-重点" class="headerlink" title="9.3.2 查询树的启发式优化(重点)"></a>9.3.2 查询树的启发式优化(重点)</h3><ol><li>选择运算应尽可能先做</li><li>把投影运算和选择运算同时进行：这两者都是一元操作，一个元组能不能成为结果只取决于其本身</li><li>把投影同其前或后的双目运算结合起来</li><li>把某些选择同在它前面要执行的笛卡儿积结合起来称为一个连接运算</li><li>找出公共子表达式<img src="C:\Users\86158\Desktop\20180806204751503.png"></li></ol><h2 id="9-4-物理优化"><a href="#9-4-物理优化" class="headerlink" title="9.4 物理优化"></a>9.4 物理优化</h2><blockquote><p>方法:</p></blockquote><pre><code>1. 基于规则的启发式优化2. 基于代价估算的优化3. 两者结合的优化方法</code></pre><h3 id="9-4-1-基于启发式规则的存取路径选择优化"><a href="#9-4-1-基于启发式规则的存取路径选择优化" class="headerlink" title="9.4.1 基于启发式规则的存取路径选择优化"></a>9.4.1 基于启发式规则的存取路径选择优化</h3><p><strong>选择操作的启发式规则：</strong></p><ul><li>小关系 : 全表扫描</li><li>大关系：</li></ul><ol><li>对于选择条件是”主码=值”的查询，则可以选择主码索引，因为主码索引一般是被自动建立的</li><li>对于选择条件是”非主属性=值”查询，并且选择列上有索引，如果选择比例较小（10%）可以使用索引扫描，否则全表扫描</li><li>对于选择条件是属性上的非等职查询或者范围查询，同上</li><li>对于用AND连接的合取选择条件，若有组合索引，优先用组合索引方法；如果某些属性上有一般索引，则用索引扫描，否则全表扫描</li><li>对于用OR连接的析取选择条件，全表扫描</li></ol><p>连接操作的启发式规则</p><ol><li><p>若两个表都已经按连接属性排序，则选用排序-合并算法</p></li><li><p>若一个表在连接属性上有索引，则使用索引连接方法</p></li><li><p>若其中一个表较小，则选用hash join</p></li><li><p>最后可以使用嵌套循环，小表坐外表</p></li></ol><h1 id="第10章-数据库恢复技术"><a href="#第10章-数据库恢复技术" class="headerlink" title="第10章 数据库恢复技术"></a>第10章 数据库恢复技术</h1><h2 id="10-1-事务的基本概念"><a href="#10-1-事务的基本概念" class="headerlink" title="10.1 事务的基本概念"></a>10.1 事务的基本概念</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h3><blockquote><p>事务：是用户定义的数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</p></blockquote><p>在sql中，定义事务的语句有三条：</p><ol><li> begin transaction 表示开始</li><li> commit 提交</li><li> rollback 撤销</li></ol><h3 id="2-事务的ACID特性"><a href="#2-事务的ACID特性" class="headerlink" title="2.事务的ACID特性"></a>2.事务的ACID特性</h3><ol><li> 原子性 atomicity</li><li> 一致性 consistency 和原子性密切相关   一致性状态（正常）   中断（不一致） 所以要保证原子性</li><li> 隔离性 isolation 并发执行的各个事务之间不能干扰</li><li> 持续性 durability 永久性 事务一旦提交，改变就是永久性的，其他操作不能影响其结果</li></ol><blockquote><p>ACID特性可能遭到破坏的因素：</p><p>1. 多个事务并行运行，不同事务的操作交叉执行；</p><p>2. 事务在运行过程中被强行停止。</p></blockquote><h2 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a>10.3 故障的种类</h2><h3 id="1-事务内部的故障"><a href="#1-事务内部的故障" class="headerlink" title="1. 事务内部的故障"></a>1. 事务内部的故障</h3><p>非预期的，不能有由应用程序处理</p><p>发生后需要  事务撤销</p><h3 id="2-系统故障"><a href="#2-系统故障" class="headerlink" title="2. 系统故障"></a>2. 系统故障</h3><p>断电、死机</p><p>系统重启后，不仅要撤销所有未完成的事务，还要重做所有已提交的事务</p><h3 id="3-介质故障"><a href="#3-介质故障" class="headerlink" title="3. 介质故障"></a>3. 介质故障</h3><p>硬故障 磁盘损坏、磁头碰撞、瞬间强磁场干扰</p><h3 id="4-计算机病毒"><a href="#4-计算机病毒" class="headerlink" title="4. 计算机病毒"></a>4. 计算机病毒</h3><blockquote><p>总结，各类故障对DB的影响有两种：</p><p>1. 数据库本身被破坏</p><p>2. 没破坏，但数据不对了</p><p>恢复的原理：冗余</p></blockquote><h2 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a>10.4 恢复的实现技术</h2><h3 id="10-4-2-日志文件"><a href="#10-4-2-日志文件" class="headerlink" title="10.4.2 日志文件"></a>10.4.2 日志文件</h3><blockquote><p>用来记录事务对数据库的更新操作的文件</p><p>日志文件的作用：P299</p><ol><li></li></ol></blockquote><p>两种：</p><p>1. 以记录为单位的</p><p>需要记录：</p><blockquote><p>1. 各个事务的开始</p><p>2. ················结束</p><p>3. ················所有更新操作</p><p>一个事务就是一个日志记录</p><p>每个日志记录包括：</p><p>1.</p></blockquote><p>2. 以数据块为单位的</p><h1 id="试题"><a href="#试题" class="headerlink" title="试题:"></a>试题:</h1><p><strong>什么是数据库的再组织和重构造？为什么要进行数据库的再组织和重构造？</strong><br>[参考答案 ] 答：数据库的再组织是指：按原设计要求重新安排存储位置、回收垃圾、减少指针链等， 以提高系统性能。 数据库的重构造则是指部分修改数据库的模式和内模式， 即修改原设计的逻辑和物理结构。数据库的再组织是不修改数<br>据库的模式和内模式的。 进行数据库的再组织和重构造的原因： 数据库运行一段时间后，由于记录不断 增、删、改，会使数据库的物理存储情况变坏，降低了数 据 的 存 取 效 率 ，数 据库 性能 下 降 ， 这 时 DBA 就 要 对 数 据库 进行 重组织。 DBMS一般都提供用于数据重组织的实用程序。数据库应用环境常常发生变化，如增加新的应用或新的实体， 取消了某些应用， 有的实体与实体间的联系也发生了变化等， 使原有的数据库设计不能满足新的需求，需要调整数据库的模式和内模式。这就要进行数据库重构造</p><p><strong>什么是检查点记录？</strong><br>答：检查点记录是一类<strong>新的日志记录</strong>。它的内容包括：（1）<strong>建立检查点时刻</strong>所有正在执行的事务清单；（2）这些事务的<strong>最近</strong>一个<strong>日志</strong>记录的地址。</p><p><strong>关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一般是如何分别进行处理的？</strong><br>答:<br>对于违反实体完整性和用户定义的完整性的操作一般都采用<strong>拒绝执行</strong>的方式进行处理。而对于违反参照完整性的操作，并不都是简单地拒绝执行，有时要根据应用语义执行<strong>一些附加的</strong>操作，以保证数据库的正确性。</p><p><strong>什么是数据库的审计功能，为什么要提供审计功能？</strong><br>答：审计功能是指 DBMS 的<strong>审计模块</strong>在用户对数据库执行操作的同时把所有操作自动记录到系统的审计日志中。因为任何系统的安全保护措施都不是完美无缺的，蓄意盗窃破坏数据的人总可能存在。利用数据库的审计功能， <strong>DBA</strong> 可以<strong>根据审计跟踪的信息</strong>，重现导致数据库现有状况的一系列事件，<strong>找出非法存取数据的</strong>人、时间和内容等。</p><p><strong>哪类视图是可以更新的？哪类视图是不可更新的？各举一例说明。</strong><br>答：基本表的<strong>行列子集视图</strong>一般是可更新的。若视图的属性来自集合函数、表达式，则该视图<strong>肯定是</strong>不可以更新的。</p><p><strong>什么是基本表？什么是视图？两者的区别和联系是什么？</strong><br>答：基本表是本身独立存在的表， 在 sQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图<strong>本身不独立存储在数据库中</strong>，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，<strong>这些数据</strong>仍存放在导出视图的基本表中。 视图在概念上与基本表等同， 用户可以如同基本表那样使用视图，可以在视图上再定义视图</p><p><strong>假设有下面两个关系模式：</strong></p><p>职工（职工号，姓名，年龄，职务，工资，部门号） ，其中职工号为主码；</p><p>部门（部门号，名称，经理名，电话） ，其中部门号为主码。</p><p>用 sQL 语言定义这两个关系模式，要求在模式中完成以下完整性约束条件的定义：</p><p>定义每个模式的<strong>主码</strong>；</p><p>定义<strong>参照完整性</strong>； 定义职工年龄不得超过 60岁。<br>答<br>CREATE TABLE DEPT<br>(Deptno NUMBER(2) <strong>PRIMARY KEY,</strong><br>Deptname VARCHAR(10),<br>Manager VARCHAR(10),<br>PhoneNumber Char(12)<br>);</p><p>CREATE TABLE EMP<br>(Empno NUMBER(4) <strong>PRIMARY KEY,</strong><br>Ename VARCHAR(10),<br>Age NUMBER(2),<br>CHECK ( Aage&lt;=60),<br>Job VARCHAR(9),<br>Sal <strong>FLOAT</strong>(6),<br>Deptno NUMBER(2),<br><strong>FOREIGN KEY(Deptno)  REFERENCES DEPT(Deptno));</strong></p><p><strong>什么是数据库中的自主存取控制方法和强制存取控制方法？</strong><br>答：<br>自主存取控制方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。<br>强制存取控制方法：每一个数据对象被（强制地）标以一定的密级，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。</p><p><strong>试述实现数据库安全性控制的常用方法和技术。</strong><br>答：实现数据库安全性控制的常用方法和技术有：<br>( l  ）<strong>用户标识和鉴别</strong>：该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权。<br>( 2 ）<strong>存取控制</strong>：通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。例如 CZ 级中的自主存取控制 ( DAC ) , Bl  级中的强制存取控制（ MAC ）。<br>( 3 ）<strong>视图机制</strong>：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。<br>( 4 ）<strong>审计</strong>：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中， DBA 可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。<br>( 5 ）<strong>数据加密</strong>：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。</p><blockquote><ol><li> DB具有数据独立性的原因：三级模式结构</li><li> 逻辑数据和物理数据的转换由DBMS负责</li><li> 在嵌入式 SQL 中，当 SQL 语句中引用宿主语言的程序变量时，程序变量应加前缀：</li><li> 在关系代数表达式的查询优化中，不正确的叙述是 尽可能早地执行连接</li><li> 下列哪类不属于计算机系统的安全问题 政策安全类</li><li> 数据库设计人员和用户之间沟通信息的桥梁是 实体联系图</li><li> 并行数据库系统研究一直以三种并行计算结构为基础，分别是 <strong>共享内存结构、共享磁盘结构、无共享资源结构</strong></li><li> RDBMS查询处理可以分为四个阶段，包括 <strong>查询分析、检查、优化、执行</strong></li></ol></blockquote><p>参考文献：</p><ol><li>本文章框架摘抄自<a href="https://github.com/ggrp-china/reviewdatabase.git">github</a>，并在期末考试阶段加以补充</li><li><a href="https://www.cnblogs.com/guanghe/p/14788762.html">关系模式</a></li><li><a href="https://blog.csdn.net/Wenco1/article/details/88077279">关系范式详解</a></li><li><a href="https://www.cnblogs.com/guanghe/p/14788762.html">模式分解</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较器</title>
      <link href="/2021/12/04/%E6%AF%94%E8%BE%83%E5%99%A8/"/>
      <url>/2021/12/04/%E6%AF%94%E8%BE%83%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li> 比较器的实质就是重载比较运算符</li><li> 比较器可以很好的应用在特殊标准的排序上</li><li> 比较器可以很好的应用在根据特殊标准排序的结构上</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>返回负数的时候，第一个参数排在前(上)面</p></li><li><p>返回正数的时候，第二个参数排在后(下)面</p></li><li><p>返回0的时候,谁在其那面无所谓</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IdAscendingComparator implements Comparator&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Stduent o1 , Student o2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个比较器 实现大根堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> AComp)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/12/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><em>宋词 : 《忆秦娥 娄山关》</em></p><p><code>西风烈</code></p><p><code>长空雁叫霜晨月</code></p><p><code>雄关漫道真如铁</code></p><p><code>而今漫步从头越</code></p><p><em>宋词：《忆排序 面试官》</em></p><p><code>选泡插</code></p><p><code>快归堆希统计基</code></p><p><code>恩放恩老恩一三 ， 对恩加K恩乘K</code> </p><p><code>不稳稳稳不稳稳 ， 不稳不稳稳稳稳</code></p><p><img src="https://i.loli.net/2021/12/02/VLqay1mWJdnpf78.png" alt="image-20211126195750155.png"></p><p>基于比较的排序</p><p>不基于比较的排序：不根据数据状况进行排序</p><p>不基于比较的排序：计数排序，桶排序。根据数据状况进行的排序</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ol><li>记录数组第一个元素的值,遍历n-1次,用该值与其他元素比较,找到最大或者最小的一个交换</li><li>记录数组第二个元素的值,遍历n-2次,用该值与其他元素比较,找到最大或者最小的一个交换</li><li>重复上述步骤,遍历N次,直到没有要比较的数</li></ol><p><a href="https://blog.csdn.net/changhangshi/article/details/82740541">参考链接</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> N = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N-<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j++) &#123;</span><br><span class="line">        minIndex = arr[j] &gt; arr[minIndex] ? minIndex : j;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr , minIndex , i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ol><li><p>从第一个元素开始比较相邻的两个元素，如果第一个比第一个大或小，就互换它们的位置</p></li><li><p>然后抛弃最大或最小数(经过一轮,最大或最小的数已经移到最后)</p></li><li><p>继续比较直到排序完成。</p></li></ol><p><a href="https://blog.csdn.net/weixin_53911377/article/details/114410687">参考链接</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> N = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=N-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>1.从第一个元素开始，该元素可以认为已经被排序<br>2.取下一个元素tem，从已排序的元素序列从后往前扫描<br>3.如果扫描到的元素大于tem，则将该元素移到下一位，并继续向前扫描<br>4.重复步骤3，直到找到已排序元素中小于等于tem的元素<br>5.tem插入到该元素的后面，如果已排序所有元素都大于tem，则将tem插入到下标为0的位置<br>6.重复步骤2~5<br><a href="https://blog.csdn.net/weixin_50886514/article/details/119045154">参考链接</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;<span class="comment">//希望0-arr.length变得有序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j&gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j+<span class="number">1</span>];j--)&#123;</span><br><span class="line">        swap(arr , j , j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ol><li><p>当我们要排序这样一个数组的时候，归并排序法首先将这个数组分成一半</p></li><li><p>然后想办法把左边的数组给排序，右边的数组给排序，之后呢再将它们归并起来。当然了当我们对左边的数组和右边的素组进行排序的时候，再分别将左边的数组和右边的数组分成一半，然后对每一个部分先排序，再归并.</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []arr , <span class="keyword">int</span> L , <span class="keyword">int</span> M , <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= M)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">        arr[L+j] = help[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> []arr , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    mergesort(arr,L,mid);</span><br><span class="line">    mergesort(arr,mid+<span class="number">1</span>,R);</span><br><span class="line">    merge(arr,L,mid,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><h3 id="荷兰国旗问题-简化版"><a href="#荷兰国旗问题-简化版" class="headerlink" title="荷兰国旗问题(简化版)"></a>荷兰国旗问题(简化版)</h3><p>对于某一个数组，要求小于等于某个数M的部分都放到M的左边，大于M的部分都在放到M的右边（不要求两部分数有序）</p><p><em>解题思路 ：</em></p><ol><li>arr[i] &lt;= num： arr[i]和**&lt;=区域<strong>的下一个数</strong>交换<strong>，</strong>&lt;=区域<strong>向右</strong>扩张一位<strong>，指针</strong>i++**</li><li>arr[i] &gt; num：指针<strong>i++</strong></li><li>直到<strong>指针i越界</strong></li></ol><p><img src="https://i.loli.net/2021/12/02/Zd2qirMxUVwjoAk.png" alt="原理.png"></p><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>对于某一个数组，要求小于某个数M的部分都放到M的左边，等于M的部分放到中间,大于M的部分都在放到M的右边（不要求三部分数有序</p><p><em>解题思路 :</em></p><ol><li>arr[i] &lt; num： arr[i]和**&lt;=区域<strong>的下一个数</strong>交换<strong>，</strong>&lt;=区域<strong>向右</strong>扩张一位<strong>，指针</strong>i++**</li><li>arr[i] &gt; num：arr[i]和**&gt;=区域<strong>的前一个数</strong>交换<strong>，</strong>&lt;=区域<strong>向左</strong>扩张一位<strong>，指针</strong>i原地不变**<ul><li>为啥i原地不动? 因为i是新被换过来的,还没判断过呢</li></ul></li><li>arr[i]  == num：<strong>指针i++</strong></li><li>直到<strong>大于区域和i相遇</strong></li></ol><p><img src="https://i.loli.net/2021/12/02/3konFiTLPUI9wjR.png" alt="86EE5398A709E386FCF1D10A25806B3E.png"></p><h2 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="快速排序1-0"><a href="#快速排序1-0" class="headerlink" title="快速排序1.0"></a>快速排序1.0</h3><ol><li>选择数组最后的一个作为num，把除去num的前面n-1个元素按照上述：&lt;=num的放在左边，&gt;num的放在右边</li><li>把小于等于区域后的第一个元素和num交换</li><li>对小于等于和大于的部分递归</li></ol><p><img src="https://i.loli.net/2021/12/02/ofMA4herxPqGLjF.png" alt="快排1.0.png"></p><h3 id="快速排序2-0"><a href="#快速排序2-0" class="headerlink" title="快速排序2.0"></a>快速排序2.0</h3><ol><li>选择数组最后一个作为num，把除去num的前面的n-1个元素按照荷兰国旗问题：＜num的放在左边，=num的放在中间，＞num的放在右边</li><li>把大于区域的第一个元素和num交换</li><li>对小于和大于的部分递间归（因为一下子搞定了一批等于num的数，所以比1.0更快一点）</li></ol><h3 id="快速排序3-0"><a href="#快速排序3-0" class="headerlink" title="快速排序3.0"></a>快速排序3.0</h3><p>等概率随机选择一个num做划分值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span>[] partition(<span class="keyword">int</span> []arr , <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = L;</span><br><span class="line">        <span class="keyword">int</span> left = L-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = R;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[R]) swap(arr , i++ , ++left);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == arr[R]) i++;</span><br><span class="line">            <span class="keyword">else</span> swap(arr,i,--right);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,right,R);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left+<span class="number">1</span> , right&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] arr , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt; R)&#123;</span><br><span class="line">            swap(arr , L+(<span class="keyword">int</span>)(Math.random() * (R-L+<span class="number">1</span>)),R);</span><br><span class="line">            <span class="keyword">int</span> []p = partition(arr , L  ,R);<span class="comment">//p记录等于num的左边界和右边界</span></span><br><span class="line">            quicksort(arr,L,p[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">            quicksort(arr,p[<span class="number">1</span>]+<span class="number">1</span>,R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>快排1.0</th><th>快排2.0</th><th>快排3.0</th></tr></thead><tbody><tr><td>时间复杂度</td><td>能够举出最坏的例子， O(N^2)</td><td>能够举出最坏的例子， O(N^2)</td><td>O(n*logn)</td></tr><tr><td>空间复杂度</td><td>O(logn)</td><td>O(logn)</td><td>O(logn)</td></tr></tbody></table><p>好情况 : 最后一个数正好处于数组中</p><p>坏情况 : 最后一个数打的很偏</p><h1 id="堆排序-堆结构"><a href="#堆排序-堆结构" class="headerlink" title="堆排序 : 堆结构"></a>堆排序 : 堆结构</h1><h2 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h2><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树：对于一颗二叉树，要么这棵树的每一层都是满的，要么这棵树的最下面一层正在<strong>从左向右依次</strong>变满。就称这棵树是完全二叉树。</p><pre><code>1. 从零开始的连续一段数组可以等同于一个完全二叉树</code></pre><ol start="2"><li>i位置的左孩子 : 2*i+1</li><li>i位置的右孩子: 2*i+2</li><li>i位置的父节点: (i-1)/2</li></ol><h3 id="堆结构-1"><a href="#堆结构-1" class="headerlink" title="堆结构"></a>堆结构</h3><p>堆结构是一颗完全二叉树</p><ol><li>大根堆 : 以任何一个节点M为根,则以这个节点为根的整棵树的最大值为M(每一刻子树的最大值是头结点的值)</li><li>小根堆 : 以任何一个节点M为根,则以这个节点为根的整棵树的最小值为M(每一刻子树的最小值是头结点的值)</li></ol><h2 id="堆的相关操作"><a href="#堆的相关操作" class="headerlink" title="堆的相关操作"></a>堆的相关操作</h2><h3 id="堆调整-堆插入heapinsert-以大根堆为例"><a href="#堆调整-堆插入heapinsert-以大根堆为例" class="headerlink" title="堆调整: 堆插入heapinsert(以大根堆为例)"></a>堆调整: 堆插入heapinsert(以大根堆为例)</h3><ol><li>对于新加入数组中的某个数字 , 循环与其父节点判断。如果大于其父节点，就和父节点交换，并且继续与其新的父节点交换。直到小于等于其父节点，就停止。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> []arr , <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">//int a = (index-1)&gt;&gt;1;                 省掉了额外一个变量的定义</span></span><br><span class="line">    <span class="keyword">while</span>(arr[index] &gt; arr[(index-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>])&#123;<span class="comment">//这里包括了两种停止的可能性。第一种：该节点M比父节点M小。第二种：arr[0] &gt; arr[0]</span></span><br><span class="line">        swap(arr,index,(index-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        index = (index-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调整堆-heapify返回并删除最大值"><a href="#调整堆-heapify返回并删除最大值" class="headerlink" title="调整堆 : heapify返回并删除最大值"></a>调整堆 : heapify返回并删除最大值</h3><ol><li>将arr[heapsize–]的数据覆盖arr[0]</li><li>之后令arr[0]与其左右孩子的最大值比较。如果小于左右孩子的最大值，就与其交换，并继续比较。如果大于左右孩子的最大值，就停止比较。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> []arr , <span class="keyword">int</span> index,<span class="keyword">int</span> heapSize )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; heapSize)&#123;<span class="comment">//当下方还有孩子的时候。注意，此时heapSize!=arr.length</span></span><br><span class="line">        <span class="comment">//两个孩子之间的大小比较</span></span><br><span class="line">        <span class="keyword">int</span> largest = left+<span class="number">1</span> &lt; heapSize &amp;&amp; arr[left+<span class="number">1</span>] &gt; arr[left] ? left+<span class="number">1</span> : left;</span><br><span class="line">        <span class="comment">//父子之间的大小比较</span></span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(largest == index) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr , largest , index);</span><br><span class="line">        indedx = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改了节点（添加节点）"><a href="#修改了节点（添加节点）" class="headerlink" title="修改了节点（添加节点）"></a>修改了节点（添加节点）</h3><ul><li><p>如果这个节点比原来的节点大，就heapinsert。调整代价O(logn)；</p></li><li><p>如果这个节点比原来的节点小，就heapify。调整代价O(logn)；</p></li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol><li>初始化heapsize = 0</li><li>相当于每次都是用户给你一个新的数据 ，执行heapinsert，heapsize++；</li><li>把arr[0]与arr[heapsize–]做交换。此时整个完全二叉树的最大值放到了数组的最后一个位置，heapsize–代表将最大的这个数同剩余的堆断开联系。（已经排好了）</li><li>从arr[0]做heapify，使剩下的数字继续变成大根堆。</li><li>重复上述工作，直到heapsize==0;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> &amp;&amp; arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) heapInsert(arr,i);<span class="comment">//1</span></span><br><span class="line">    <span class="comment">//for(int i = arr.length-1 ;i&gt;=0;i--) heapify(arr,i,arr.length)//2</span></span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">    <span class="keyword">while</span>(heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        heapify(arr,<span class="number">0</span>,heapSize);</span><br><span class="line">        swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让一个数组变成大根堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) heapInsert(arr,i);<span class="comment">//1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length-<span class="number">1</span> ;i&gt;=<span class="number">0</span>;i--) heapify(arr,i,arr.length)<span class="comment">//更快(这里的heapsize是不变的)</span></span><br></pre></td></tr></table></figure><h2 id="堆排序拓展题目"><a href="#堆排序拓展题目" class="headerlink" title="堆排序拓展题目"></a>堆排序拓展题目</h2><p>已知一个几乎有序的数组。几乎有序是指，如果把数组拍好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说是比较小的。请选择一个合适的排序算法针对这个数组进行排序。</p><p><em>解题思路</em></p><ol><li>准备一个小根堆，遍历数组。（假设K=6）</li><li>利用堆排序遍历前7个数。</li><li>此时，整个数组的最小值一定在0位置上。因为7及7以后的数在K的限制下不可能让最小值出现在0位置上。</li><li>把0位置弹出，再向右包含一个数字。周而复始。</li></ol><h3 id="关于Java中的优先队列"><a href="#关于Java中的优先队列" class="headerlink" title="关于Java中的优先队列"></a>关于Java中的优先队列</h3><p>优先级队列底层就是结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">heap.add();</span><br><span class="line">heap.poll();</span><br><span class="line">heap.isEmpty();</span><br></pre></td></tr></table></figure><p>*如何扩容 :*成倍扩容</p><p>各语言的堆结构虽然方便，但是不能完全满足需求。有的时候手写</p><p>不能够完成或者效率很低：改变内部的值,并且调节成堆结构</p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><ol><li>建立一个和原数组登场的空数组空间，初始值为0，遍历该数组。</li><li><code>计数序列中每个元素出现的次数</code>,我们将每个元素的数量都记录下来之后.建立词频统计表。比如10出现2次，就把新开的数组空间的10号位置记为2.</li></ol><p>举个例子：</p><p>员工的年龄，从0-100岁。准备一个额外100长度的数组作为频率统计表。只需要遍历一次数组，就可以建立起词频统计表。再次遍历一次数组，就可以实现排序。</p><p>举个例子：</p><p>如果数据的范围是从-100000到+100000。那么就需要开2000000长度的数组。无法实现</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><ol><li>例如待排序的数组是10位数，就准备10个桶、</li><li>首先根据数组各元素的个位数排序。各个元素的个位数是什么，就把他放到哪个桶里。（如017放到7号桶里）</li><li>将0-9号桶的内容一次放回原来的数组。</li><li>再根据十位数、百位数重复上述工作。</li></ol><p>前缀和的原因：各自使用各自的片。</p><p><a href="https://www.bilibili.com/video/BV13g41157hK?p=4">参考链接:空降2:09:00</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[]arr , <span class="keyword">int</span> L , <span class="keyword">int</span> R , <span class="keyword">int</span> digit)</span><span class="comment">//digit是数组中最大的那个数有多少个位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> radix = <span class="number">10</span>;<span class="comment">//基底</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[]backet = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=digit;d++)&#123;<span class="comment">//入桶出桶的要几次</span></span><br><span class="line">         <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[radix];</span><br><span class="line">        <span class="keyword">for</span>(i=L; i&lt;= R ;i++)&#123;</span><br><span class="line">            j = getDigit(arr[i] , d);</span><br><span class="line">            count[j]++;<span class="comment">//词频表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;radix;i++)&#123;</span><br><span class="line">count[i] = count[i] + count[i-<span class="number">1</span>];<span class="comment">//获得前缀和词频表(每个位置表示个(十位百位)位数字小于等于i的又多少个)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=R;i&gt;=L;i--)&#123;<span class="comment">//从右往左,把count数组的数放到bucket中,等于完成了一次出桶  </span></span><br><span class="line">            j = getDigit(arr[i] , d);</span><br><span class="line">            bucket[count[j] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = L,j=<span class="number">0</span>;i&lt;=R;i++,j++)&#123;</span><br><span class="line">            arr[i] = bucket[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治思想-归并排序改编</title>
      <link href="/2021/12/02/%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%94%B9%E7%BC%96/"/>
      <url>/2021/12/02/%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%94%B9%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="分治思想-归并排序改编"><a href="#分治思想-归并排序改编" class="headerlink" title="分治思想 - 归并排序改编"></a>分治思想 - 归并排序改编</h1><h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><p><strong>分治思想，由归并排序改编而来</strong></p><p>在一个数组中，每一个数 左边比当前树小的数累加起来，叫做这个数组的小和。求一个数组的小和。</p><p><em>等价于 ：每一个数右边有多少个数比他大，就产生多少个该数的小和</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">对<span class="number">1</span> : 右边有<span class="number">4</span>个数比他大, 产生<span class="number">4</span>个<span class="number">1</span>的小和</span><br><span class="line">对<span class="number">3</span> : 右边有<span class="number">2</span>个数比他大, 产生<span class="number">2</span>个<span class="number">3</span>的小和</span><br><span class="line">对<span class="number">4</span> : 右边有<span class="number">1</span>个数比他大, 产生<span class="number">1</span>个<span class="number">4</span>的小和</span><br><span class="line">…………</span><br><span class="line"><span class="comment">//所以可以使用归并排序轻松的算出一个数右边有多少个数比他大,这样也可以算出小和</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">1,3,4,2,5 --&gt; 1,3,4</span><br><span class="line">1,3,4,2,5 --&gt; 2,5 --&gt; 2 &amp; 5</span><br><span class="line">1,3,4 --&gt; 1,3 --&gt;1 &amp; 3</span><br><span class="line">1,3,4 --&gt; 4</span><br></pre></td></tr></table></figure><p> <em>分批的, 不遗漏不重算的查找所有的小和</em></p><ol><li>对树叶[1](左) [3](右)<strong>merge</strong> ，右边比左边大,记录下1个1的小和并且把左边的指针向右移动一位。此时左边越界，直接把右边拷贝。<ul><li>用O(1)的时间知道右有几个数比左大。通过下标直接计算出右组有几个数比左边当前的数大。</li><li>如果两个数相等，必须要把右边的指针往后移，并且不记录小和。只有左组中的元素绝对比右组中的元素小，才能够通过下表的范式直接计算出右组中有几个数比左组当前数大。</li></ul></li><li>把树叶[1](左) [3](右)的父节点使用排序[1] [3]merge后的数组覆盖。重复。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L , <span class="keyword">int</span> M ,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []help = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = L;</span><br><span class="line">        <span class="keyword">int</span> p2 = M+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=M &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">            sum += arr[p1] &lt; arr[p2] ? (R-p2+<span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= M)&#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= R)&#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;help.length;j++)&#123;</span><br><span class="line">            arr[L+j] = help[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">smallsum</span><span class="params">(<span class="keyword">int</span> [ ]arr,<span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R-L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        smallsum(arr,L , mid);</span><br><span class="line">        smallsum(arr , mid+<span class="number">1</span> , R);</span><br><span class="line">        merge(arr,L,mid,R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        smallsum(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h2><p>在一个数组中,左边的树如果比右边的数大，则这两个数构成一个逆序对，请打印所有的逆序对</p><p><em>小和问题求的是右边有多少个数比左边大，本题求的是右边有多少个数比左边小。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分治思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算-异或</title>
      <link href="/2021/12/01/%E4%BD%8D%E8%BF%90%E7%AE%97-%E5%BC%82%E6%88%96/"/>
      <url>/2021/12/01/%E4%BD%8D%E8%BF%90%E7%AE%97-%E5%BC%82%E6%88%96/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="异或满足交换律和结合律"><a href="#异或满足交换律和结合律" class="headerlink" title="异或满足交换律和结合律"></a>异或满足交换律和结合律</h2><p>一个小题目：</p><ol><li>已知某一个数组中，有一个数出现了奇数次，其他的数都出现了偶数次。请问这个数是啥？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[1,6,1,2,6,6,2,2,2]</span></span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.lenth;i++)&#123;</span><br><span class="line">    eor ^= array[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eor;<span class="comment">//eor即为结果</span></span><br></pre></td></tr></table></figure><p><em>解析 ： 异或满足交换律</em></p><p>eor ^ [1, 6,1,2,6,6,2,2,2] == eor ^ [1,1,2,2,2,2,6,6,6]</p><ol start="2"><li>已知某一个数组中，有两个数(a != b)出现了奇数次，其他的数出现了偶数次。请问这两个数是啥</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[1,6,1,2,6,6,2,2,2]</span></span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : array)&#123;</span><br><span class="line">    eor ^= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//eor == a ^ b;  eor!=0;(a != b)</span></span><br><span class="line"><span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);<span class="comment">//提取eor最右边的那个1</span></span><br><span class="line"><span class="keyword">int</span> eor2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &amp; rightOne == <span class="number">0</span>)&#123;<span class="comment">//0或者1都行</span></span><br><span class="line">        eor2 ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eor + <span class="string">&quot; &quot;</span> + (eor ^ eor2))</span><br></pre></td></tr></table></figure><p><em>解析</em></p><p>此时eor至少有一位不等于0；我们假设是第1位 , 那么a的第一位和b的第一位一定是不一样的。</p><p>则另准备一个变量eor2 ， 让他异或上所这个数组中所有第一位不是0的数。此时最终eor2的值为eor2 == a or b;(此时已经找到一个目标了)</p><p>eor ^ eor2 = b or a;(找到第二个目标)</p><h2 id="异或的性质"><a href="#异或的性质" class="headerlink" title="异或的性质"></a>异或的性质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. a ^ a = 0;</span><br><span class="line">2. a ^ 0 = a;</span><br><span class="line">3. 无进位相加</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异或实现两两数交换</span></span><br><span class="line"><span class="comment">//前提:两个index不能指向同一个内存空间</span></span><br><span class="line"><span class="comment">//精确到数组,即index1 != index2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a ,<span class="keyword">int</span> left ,<span class="keyword">int</span> right)</span></span>&#123;<span class="comment">//前提是left != right 否则会变成0</span></span><br><span class="line">        a[left] = a[left] ^ a[right];</span><br><span class="line">        a[right] = a[left] ^ a[right];</span><br><span class="line">        a[left] = a[left] ^ a[right];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对数器</title>
      <link href="/2021/12/01/%E5%AF%B9%E6%95%B0%E5%99%A8/"/>
      <url>/2021/12/01/%E5%AF%B9%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h1><p>方法a(想测)   随机样本产生器.在结果1和结果2中同时跑2</p><p>方法b</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Math.random() //[0,1)所有小数,等概率返回一个</span></span><br><span class="line"><span class="comment">//Math.random() * N  //[0,N)所有小数,等概率返回一个</span></span><br><span class="line"><span class="comment">//(int)(Math.random() * N)      //[0,N-1]所有的整数,等概率返回一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRamdomArray(<span class="keyword">int</span> maxSize , <span class="keyword">int</span> maxValue)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)(maxSize+<span class="number">1</span>) * Math.random())];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length.i++)&#123;</span><br><span class="line">         arr[i] = (<span class="keyword">int</span>)((maxValue+<span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>)(maxValue * Math.random());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> testTime = <span class="number">500000</span>;</span><br><span class="line">    <span class="keyword">boolean</span> succeed = <span class="function"><span class="keyword">true</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;testTime;i++)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = generateRandomArray(maxSize , maxValue);</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line">        insertsort(arr1);</span><br><span class="line">        comparator(arr2);</span><br><span class="line">        <span class="keyword">if</span>(isEqual(arr1 , arr2))&#123;</span><br><span class="line">            succeed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>父类指针（或引用）指向父类对象和子类对象时的深刻理解(多态、重载、赋值兼容)</title>
      <link href="/2021/11/30/%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%EF%BC%88%E6%88%96%E5%BC%95%E7%94%A8%EF%BC%89%E6%8C%87%E5%90%91%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3/"/>
      <url>/2021/11/30/%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%EF%BC%88%E6%88%96%E5%BC%95%E7%94%A8%EF%BC%89%E6%8C%87%E5%90%91%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生活不知眼前的苟且，还有诗和远方……</p></blockquote><h1 id="赋值兼容规则"><a href="#赋值兼容规则" class="headerlink" title="赋值兼容规则"></a>赋值兼容规则</h1><ul><li>父类的指针指向父类的对象时 : 访问父类的成员</li><li>父类的指针指向子类的对象时 : 访问子类从父类继承下来的那部分数据成员</li></ul><h1 id="函数隐藏"><a href="#函数隐藏" class="headerlink" title="函数隐藏"></a>函数隐藏</h1><p><em>当子类和父类拥有同名的成员变量的时候</em></p><ul><li>父类的指针指向子类对象 : 访问的是继承来的父类中的同名成员变量(成员函数)</li><li>在子类内部或者用子类的对象在子类外访问此同名成员，访问自己类中重新定义的成员</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><em>当子类中重写了父类的虚函数</em></p><ul><li>父类的指针指向父类对象 ： 调用的是父类中的虚函数</li><li>父类的指针指向子类对象 ： 调用的是子类的虚函数<ul><li>当父类的指针指向子类对象时，此时<strong>子类对象中</strong> <strong>从父类继承下的虚函数指针所指向的虚函数表</strong>中的虚函数的入口地址<strong>被子类重写</strong>，所以此时用父类的指针指向子类对象时，找到的是子类的同名虚函数地址</li></ul></li><li>同时满足赋值兼容规则（不管父类的指针指向父类对象还是子类对象，父类指针只能访问父类的内容）</li></ul><hr><h1 id="深刻理解-子类对象中的父类虚函数表指针所指向的虚函数表中虚函数的入口地址被子类重写"><a href="#深刻理解-子类对象中的父类虚函数表指针所指向的虚函数表中虚函数的入口地址被子类重写" class="headerlink" title="深刻理解 : 子类对象中的父类虚函数表指针所指向的虚函数表中虚函数的入口地址被子类重写"></a>深刻理解 : 子类对象中的父类虚函数表指针所指向的虚函数表中虚函数的入口地址被子类重写</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A constructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">         <span class="built_in">f</span>();&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;A::f()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;A::g()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;A::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">       <span class="built_in">f</span>(); <span class="built_in">g</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::f()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::g()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> main&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"><span class="comment">//test1</span></span><br><span class="line">A* p = &amp;b;<span class="comment">//父类的指针指向子类的引用.此时子类中的虚函数表中虚函数入口地址被重写</span></span><br><span class="line">p-&gt;<span class="built_in">h</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">//test2</span></span><br><span class="line">b.<span class="built_in">h</span>(); <span class="comment">//由于继承关系,子类中的虚函数表中的虚函数入口地址已经被重写.所以即使在父类中调用f(),仍然会输出重写后的函数体内容.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果:</span></span><br><span class="line"><span class="function">class A constructor</span></span><br><span class="line"><span class="function"><span class="title">A::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">class A constructor</span></span><br><span class="line"><span class="function"><span class="title">A::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">A::h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">B::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">A::g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">A::h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">B::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">A::g</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><hr><h1 id="深刻理解-重写和重载"><a href="#深刻理解-重写和重载" class="headerlink" title="深刻理解 : 重写和重载"></a>深刻理解 : 重写和重载</h1><p><strong>重载</strong> : 函数名相同 , 形参列表去除默认值后不同 , 返回值(可以)不同</p><p><strong>重写</strong> : 函数名 , 形参列表 , 返回值均相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f1 of base&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f2 of base&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f3 of base&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f4 of base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">derive</span> :</span> <span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f1 of derive&quot;</span>;&#125;<span class="comment">//重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;f2 of derive&quot;</span>;&#125;<span class="comment">//重载</span></span><br><span class="line">    <span class="comment">//int f3()&#123;cout&lt;&lt;&quot;f3 of derive&quot;&lt;&lt;endl;return 0;&#125;//都不是</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;cout&lt;&lt;<span class="string">&quot;f4 of derive&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="空虚函数"><a href="#空虚函数" class="headerlink" title="空虚函数"></a>空虚函数</h1><p>派生类并不一定必须实现基类中的虚函数。如果派生类想通过虚函数机制访问虚函数，则<strong>需要保持一条从基类到派生类的虚函数路径。</strong>许多没有使用虚函数的中间类<strong>最好也要</strong>声明一下该虚函数，以保证其后的派生类能使用该虚函数。此时，可以通过声明一个空的虚函数来达到此目的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;class base!\n&quot;</span>&lt;&lt;endl&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> :</span> <span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span> <span class="keyword">public</span> son&#123;</span><br><span class="line">   <span class="keyword">public</span> : <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;class grandson\n&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构造函数和析构函数中的虚函数-dog都不这么写"><a href="#构造函数和析构函数中的虚函数-dog都不这么写" class="headerlink" title="构造函数和析构函数中的虚函数(dog都不这么写)"></a>构造函数和析构函数中的虚函数(dog都不这么写)</h1><p>在构造函数中调用虚函数时，采用静态联编，即<strong>它所调用的虚函数是自己的类或基类中定义的函数</strong>，而不是在任何派生类中重新定义的函数.</p><p>析构函数和构造函数情况一样，即<strong>析构函数所调用的虚函数是自己类中或基类中定义的虚函数</strong>。这是因为，在对象撤销时，该对象所包含的在派生类中定义的成员先于基类子对象撤销</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;cout&lt;&lt;<span class="string">&quot;base::vf() called&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> :</span> <span class="keyword">public</span> base&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">son</span>()&#123;<span class="built_in">vf</span>();&#125;<span class="comment">//这里往上找</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="built_in">vf</span>();&#125;<span class="comment">//这里往下找</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span> <span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">grandson</span>()&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">vf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;cout&lt;&lt;<span class="string">&quot;grandson::vf() called&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    grandson gs;</span><br><span class="line">    gs.<span class="built_in">g</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果:</span></span><br><span class="line">base::<span class="built_in">vf</span>() <span class="function">called</span></span><br><span class="line"><span class="function"><span class="title">grandson::vf</span><span class="params">()</span> called</span></span><br></pre></td></tr></table></figure><p>参考文献 ：<a href="https://blog.csdn.net/gogogo_sky/article/details/73380148?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%88%B6%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-73380148.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187">CSDN gogogo_sky的博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程</title>
      <link href="/2021/11/27/Shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/11/27/Shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h1><h2 id="Shell脚本的执行方式"><a href="#Shell脚本的执行方式" class="headerlink" title="Shell脚本的执行方式"></a>Shell脚本的执行方式</h2><ul><li>脚本以<code>#!/bin/bash</code>开头</li><li>脚本需要有可执行权限 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello world!&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">脚本运行方式一</span></span><br><span class="line">chmod 744 myShell.sh#给所有者一个x权限</span><br><span class="line">.myShell.sh                 #相对路径</span><br><span class="line">/root/shell/myShell.sh #绝对路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">脚本运行方式二（不推荐）</span></span><br><span class="line">sh ./myShell.sh</span><br></pre></td></tr></table></figure><h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p><code>$ HOME </code> <code>$PWD</code> <code>$SHELL</code> <code>$USER</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;PATH=$PATH&quot;</span><br><span class="line">echo &quot;user=$USER&quot;</span><br></pre></td></tr></table></figure><h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><ul><li><p>定义变量：variable=value（<em>变量名称一般大写</em>）</p></li><li><p>撤销变量：unset variable</p></li><li><p>静态变量：readonly variable ， 注意：不能reset</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">case</span> 1</span></span><br><span class="line">A=100</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line">unset A</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">case2</span></span><br><span class="line">readonly A=99</span><br><span class="line">echo &quot;A=$A&quot;</span><br></pre></td></tr></table></figure><ul><li><p>将命令的返回值赋给变量</p><ul><li>反引号：<code>A=ls -la</code></li><li>括号：<code>A=$(ls -la)</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RESULT=`ls -la /home`</span><br><span class="line">echo $RESULT</span><br><span class="line">MY_DATE=$(date)</span><br><span class="line">echo &quot;date=$MY_DATE&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#多行注释</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">export variable=value   #(将shell变量输出位环境变量)</span><br><span class="line">source 配置文件#(让修改后的配置信息立即生效)</span><br><span class="line">echo $变量名 #(查询环境变量的值)</span><br><span class="line">!</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TOMECAT_HOME=/opt/tomcat</span><br><span class="line">export TOMCAT_HOME</span><br><span class="line"></span><br><span class="line">source /etc/profile#在输出值之前，需要让其生效</span><br><span class="line">echo $TOMCAT_HOME#查看环境变量home的值</span><br></pre></td></tr></table></figure></li></ul><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$n #n表示数字，$0表示命令本身，$1-$9代表第一到第九个参数,10以上的参数需要用大括号包含$&#123;10&#125;</span><br><span class="line">$* #代表命令行中的所有参数,$*把所有参数看成一个整体</span><br><span class="line">$@ #代表命令行中的所有参数,$@把每个参数区分对待</span><br><span class="line">$# #代表命令行中所有参数的个数</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$0 $1 $2&quot;</span><br><span class="line">echo &quot;$*&quot;</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;参数个数=$#&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;./positionPara.sh 30 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;./positionPara.sh 30 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;30 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;30 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;参数个数=2</span></span><br></pre></td></tr></table></figure><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p><code>就是shell设计者实现已经定义好的变量,可以在shell脚本中使用</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$#返回当前进程的进程号</span><br><span class="line">$!#返回后海运行的最后一个进程的进程号</span><br><span class="line">$?#最后一次执行的命令的返回状态.如果这个变量的值为0,证明上一个命令成功执行了.如果这个两名不是0(具体时间哪个值由用户自己决定),则证明上一个命令没有成功执行</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;当前的进程号=$$&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">后台的额方式运行myShell.sh</span></span><br><span class="line">./myShell.sh &amp;#通过&amp;的方式后台运行某脚本</span><br><span class="line">echo &quot;最后运行的进程号=$!&quot;</span><br><span class="line">echo &quot;执行的值=$?&quot;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#case 1</span><br><span class="line">&quot;$((运算式))&quot; 或 $[运算式]</span><br><span class="line">#case 2</span><br><span class="line">expr m + n                    #注意 , m和n之间要有空格</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">case</span> 1</span></span><br><span class="line">RESULT1=$(((2+3)*4))</span><br><span class="line">echo &quot;result=$RESULT1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">case</span> 2</span></span><br><span class="line">RESULT2=$[(2+3)*4]</span><br><span class="line">echo &quot;result=$RESULT2&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">case</span> 3</span></span><br><span class="line">TEMP=`expr 2 + 3`</span><br><span class="line">RESULT=`expr $TEMP \* 4`</span><br><span class="line">echo &quot;result=$RESULT&quot;</span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><code>[ condition ](0为true , &gt;1为false)</code></p><p><em>常见判断条件</em></p><table><thead><tr><th align="center"></th><th>两个整数的比较</th></tr></thead><tbody><tr><td align="center">=</td><td>两个字符串比较是否相等</td></tr><tr><td align="center">-lt</td><td>小于</td></tr><tr><td align="center">-le</td><td>小于等于</td></tr><tr><td align="center">-eq</td><td>等于</td></tr><tr><td align="center">-gt</td><td>大于</td></tr><tr><td align="center">-ge</td><td>大于等于</td></tr><tr><td align="center">-ne</td><td>不等于</td></tr></tbody></table><table><thead><tr><th align="center"></th><th>按照文件权限进行判断</th></tr></thead><tbody><tr><td align="center">-r</td><td>判断文件是否有读的权限</td></tr><tr><td align="center">-w</td><td>判断文件是否有写的权限</td></tr><tr><td align="center">-x</td><td>判断文件是否有执行的权限</td></tr></tbody></table><table><thead><tr><th align="center"></th><th>按照文件类型进行判断</th></tr></thead><tbody><tr><td align="center">-f</td><td>文件存在并且是一个常规的文件</td></tr><tr><td align="center">-e</td><td>文件存在</td></tr><tr><td align="center">-d</td><td>文件存在并且是一个目录</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ -e /root/shell/aaa.txt ]</span><br><span class="line">then</span><br><span class="line">echo &quot;文件存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;及格了&quot;</span><br><span class="line">elif [ condition ]</span><br><span class="line">then</span><br><span class="line">echo &quot;没及格&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">&quot;q1&quot;)</span><br><span class="line">echo &quot;一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;q2&quot;)</span><br><span class="line">echo &quot;二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;other&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">echo &quot;the sum is $i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUM=0</span><br><span class="line">for((i=1;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">done</span><br><span class="line">echo &quot;sum=$SUM&quot;</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [$i -le $1]</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;sum=$SUM&quot;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read [](参数)</span><br><span class="line">-p : 指定读取值时的指示符</span><br><span class="line">-t : 指定读取值时等待的时间(秒).如果超过这个时间还没有读入,就停止等待</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/bash</span></span><br><span class="line">read -p 10 &quot;请输入一个数字num1=&quot; NUM1</span><br><span class="line">echo &quot;你输入的值时num1=$NUM1&quot;</span><br></pre></td></tr></table></figure><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><ul><li><p><strong>basename</strong> : 返回完整路径的最后 / 的部分,常用于获取文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">basename [pathname] [suffix]</span><br><span class="line">basenaem [string]   [suffix]</span><br><span class="line">(如果suffix被指定了,则basename命令会删除掉pathname或者string中的suffix)</span><br></pre></td></tr></table></figure></li><li><p><strong>dirname</strong> : 返回完整路径最后 / 的前面的部分,常用语返回路径部分</p></li></ul><p>​    <em>Excample</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">basename /home/aaa/test.txt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;test.txt</span></span><br><span class="line">basename /home/aaa/test.txt .txt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;<span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">dirname /home/aaa/test.txt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;/home/aaa</span></span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><em>Excample</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function getSum()&#123;#括号里无形参</span><br><span class="line">SUM=$[$n1+$n2]</span><br><span class="line">echo &quot;SUM=$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;请输入第一个数n1=&quot; n1</span><br><span class="line">rear -p &quot;请输入第二个数n2=&quot; n2</span><br><span class="line"><span class="meta">#</span><span class="bash">调用getSum</span></span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure><h1 id="Shell编程综合案例"><a href="#Shell编程综合案例" class="headerlink" title="Shell编程综合案例"></a>Shell编程综合案例</h1>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路过人间的情书</title>
      <link href="/2021/11/26/%E8%B7%AF%E8%BF%87%E4%BA%BA%E9%97%B4%E7%9A%84%E6%83%85%E4%B9%A6/"/>
      <url>/2021/11/26/%E8%B7%AF%E8%BF%87%E4%BA%BA%E9%97%B4%E7%9A%84%E6%83%85%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="路过人间的情书"><a href="#路过人间的情书" class="headerlink" title="路过人间的情书"></a>路过人间的情书</h1><p>如果光凭借语言无法表达给你</p><p>那我就为你写上一万封信</p><p>第一写 指尖触碰指尖 是一瞬 如一生的时间</p><p>第二写 耳朵如何听见 兵荒马乱的心上弦</p><p>第三写 眼睛荒无人烟 直到你坠入我的人间</p><p>……</p><p>第四写 银河灿烂无边 是尘埃 也要想你倾斜</p><p>第五写 肺腑滚烫如血 不足以形容的热烈</p><p>第六写 宇宙如果毁灭 生命也 只在刹那终结</p><p>……</p><p>第七写 萤火虫的夏天</p><p>第八写 一朵玫瑰胆怯</p><p>第九写 无规则的光线 落在了你名字上面</p>]]></content>
      
      
      
        <tags>
            
            <tag> 77 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法：#Leecode121买卖股票的最佳时机</title>
      <link href="/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法：-Leecode121买卖股票的最佳时机"><a href="#贪心算法：-Leecode121买卖股票的最佳时机" class="headerlink" title="贪心算法：#Leecode121买卖股票的最佳时机"></a>贪心算法：#Leecode121买卖股票的最佳时机</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><p>记录前面的最小价格，以当天为卖出价格。计算每天的卖出价格，如果小于最小价格，就更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minprice = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> price : prices)&#123;</span><br><span class="line">    maxprofit = <span class="built_in">max</span>(maxprofit , price - minprice);</span><br><span class="line">    minprice = <span class="built_in">min</span>(minprice , price);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="贪心算法：-Leecode122买卖股票的最佳时机2"><a href="#贪心算法：-Leecode122买卖股票的最佳时机2" class="headerlink" title="贪心算法：#Leecode122买卖股票的最佳时机2"></a>贪心算法：#Leecode122买卖股票的最佳时机2</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>引用评论区第一的大佬的一句话：</p><p>“<code>[7, 1, 5, 6]</code> 第二天买入，第四天卖出，收益最大（6-1），所以一般人可能会想，怎么判断不是第三天就卖出了呢? 这里就把问题复杂化了，根据题目的意思，当天卖出以后，当天还可以买入，所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） === 6 - 1）。所以算法可以直接简化为只要今天比昨天大，就卖出。”</p><h2 id="算法实现-：-双指针"><a href="#算法实现-：-双指针" class="headerlink" title="算法实现 ： 双指针"></a>算法实现 ： 双指针</h2><ol><li>双指针</li><li>从后往前看</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = prices.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = p1 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2 &gt;= <span class="number">0</span> &amp;&amp; prices[p2] &gt;= prices[p1])&#123;<span class="comment">//这里一定要加强逻辑限定。否则保证越界</span></span><br><span class="line">                p1 = p2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p2 &gt;= <span class="number">0</span> &amp;&amp; prices[p2] &lt;= prices[p1])&#123;<span class="comment">//！这里也一定要加强逻辑限定!</span></span><br><span class="line">                profit += prices[p1] - prices[p2];</span><br><span class="line">                p1 = p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法-Leecode406根据身高重建队列</title>
      <link href="/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-Leecode406%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
      <url>/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-Leecode406%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法：-Leecode406根据身高重建队列"><a href="#贪心算法：-Leecode406根据身高重建队列" class="headerlink" title="贪心算法：#Leecode406根据身高重建队列"></a>贪心算法：#Leecode406根据身高重建队列</h1><h2 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h2><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p><strong>一般像这种数对，还设计排序的，一般根据第一个元素正向排序，第二个元素逆向排序；或者根据第一个元素逆向排序，第二个元素正向排序</strong></p><p>就本题而言：</p><p><strong>矮个子往高个子里面插，不会改变高个子的ki。但是高个子往矮个子里面插，就会改变矮个子！</strong></p><p>所以我们先按照身高降序排列，再按照Ki升序排列。这样，当我们向ans容器里面插入数据的时候，就可以依次从头遍历people容器，把每个元素的ki当做每次循环过程中向容器里插入数据的索引值（肯定是高个子先进入，然后插入一个矮个子，根据矮个子的ki插入到ans容器里。此时无论矮个子插入到高个子的前面还是后面，都不会影响高个子的位置）</p><h2 id="解决代码"><a href="#解决代码" class="headerlink" title="解决代码"></a>解决代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>() , people.<span class="built_in">end</span>() , [](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp;u , <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp;v)&#123;<span class="comment">//u和v前面加一个&amp;符号，直接内存减半，速度翻倍……为啥子哩</span></span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">0</span>] == v[<span class="number">0</span>] ? u[<span class="number">1</span>] &lt; v[<span class="number">1</span>] : u[<span class="number">0</span>] &gt; v[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = people.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt; a : people)&#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>()+a[<span class="number">1</span>],a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="算法改进：线段树"><a href="#算法改进：线段树" class="headerlink" title="算法改进：线段树"></a>算法改进：线段树</h2><p><em>Leecode执行时间最短的代码</em></p><p><code>树相关的数据结构后期再补</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">执行用时为 <span class="number">16</span> ms 的范例</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">2048</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">int</span> n=people.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">ans</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),[&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp;x,vector&lt;<span class="keyword">int</span>&gt;&amp;y)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> x[<span class="number">0</span>]&lt;y[<span class="number">0</span>]||(x[<span class="number">0</span>]==y[<span class="number">0</span>]&amp;&amp;x[<span class="number">1</span>]&gt;y[<span class="number">1</span>]);&#125;);</span><br><span class="line">        <span class="keyword">int</span> i,j,k,l;</span><br><span class="line">        <span class="comment">//对线段树进行初始化，a[i]表示以i为根的树中空座位数量</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>,k=X,l=<span class="number">1</span>;i&lt;=X*<span class="number">2</span>;i&lt;&lt;=<span class="number">1</span>,k&gt;&gt;=<span class="number">1</span>)<span class="keyword">for</span>(j=i/<span class="number">2</span>;j--;)a[l++]=k;</span><br><span class="line">        <span class="comment">//逐个找座位</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>,k=people[i][<span class="number">1</span>];j&lt;X;--a[j])&#123;</span><br><span class="line">                j&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=a[j])k-=a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[j-X]=people[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础</title>
      <link href="/2021/11/25/linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/25/linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h1><h2 id="文件基础"><a href="#文件基础" class="headerlink" title="文件基础"></a>文件基础</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong><code>删除文件</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch ./test.txt;</span><br><span class="line">rm ./test.txt;</span><br><span class="line">rm -f ./test.txt;//不询问</span><br></pre></td></tr></table></figure><p><strong><code>删除目录</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r aaa;//递归删除当前目录下的aaa目录</span><br><span class="line">rm -rf aaa;;//递归删除当前目录下的aaa目录（不询问）</span><br></pre></td></tr></table></figure><p><strong><code>全部删除</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf *将当前目录下的所有目录全部删除</span><br></pre></td></tr></table></figure><h3 id="重命名-amp-amp-剪切"><a href="#重命名-amp-amp-剪切" class="headerlink" title="重命名&amp;&amp;剪切"></a>重命名&amp;&amp;剪切</h3><p><strong><code>重命名</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 当前目录 新目录</span><br></pre></td></tr></table></figure><p><strong><code>剪切</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /user/tmp/aaa /user;</span><br></pre></td></tr></table></figure><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -r /user/temp/aaa /user#递归复制整个文件夹</span><br><span class="line">\cp -r user/tmp/aaa /user           #如果目标目录下有相同文件，会直接强制覆盖</span><br><span class="line">cp /home/aaa.txt /home/bbb #把aaa.txt文件复制到bbb文件夹里</span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name &quot;hello*&quot;;</span><br></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat helloworld.cpp</span><br><span class="line">cat -n /etc/profile | more              #显示行号、管道符、分页浏览</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">more /etc/profile</span><br><span class="line">    spcae：向下翻页</span><br><span class="line">    enter: 向下翻一行</span><br><span class="line">    q    ： lika</span><br><span class="line">    ctrl+F:向下滚动一屏</span><br><span class="line">    ctrl+B:返回上一屏</span><br><span class="line">    =     ： 显示当前行的行号</span><br><span class="line">    :f    : 输出文件名和当前行的行号</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less 射雕英雄传.txt                     #分屏查看，处理打啊性文件的时候有更高的效率</span><br><span class="line">快捷键：借步度娘</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head -n 5 /etc/profile                #显示前五行</span><br><span class="line">tail -n 5 /etc/profile                #显示后五行</span><br><span class="line">tail -f /etc/profile                  #实时追踪文档的所有更新</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br><span class="line">-n 输出之后不换行</span><br><span class="line">-e 表示对转义字符按照对应的方式进行处理</span><br><span class="line"></span><br><span class="line">echo &quot;hello world &quot; &gt; test.txt #echo重定向</span><br></pre></td></tr></table></figure><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt; a.txt #&gt;输出重定向：会把原来的文件内容覆盖</span><br><span class="line"> #&gt;&gt;不会覆盖原来文件里的内容，在末尾追加</span><br><span class="line">ls -l /home/ &gt; /home/info.txt</span><br></pre></td></tr></table></figure><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root linkToRoot               #给/root建立一个快捷方式</span><br><span class="line">rm -rf linkToRoot                    #hhh</span><br></pre></td></tr></table></figure><h3 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history</span><br><span class="line">!178                                  #执行历史命令中编号为178号的指令</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /home -name helloworld.txt      #根据名称查找该文件</span><br><span class="line">fine / -name *.txt</span><br><span class="line">-user                    #查询属于指定用户的所有文</span><br><span class="line">fine /home -size +20M                    #按照大小查询文件</span><br></pre></td></tr></table></figure><h3 id="过滤和管道符号"><a href="#过滤和管道符号" class="headerlink" title="过滤和管道符号"></a>过滤和管道符号</h3><p><code>grep</code> ：过滤查找</p><p><code>|</code>:管道符，表示将抢一个命令的处理结果输出传递到给后面的命令处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n 显示匹配行及行号</span><br><span class="line">-i 忽略字母大小写</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | grep -n yes</span><br></pre></td></tr></table></figure><h2 id="用户、用户组管理及权限管理"><a href="#用户、用户组管理及权限管理" class="headerlink" title="用户、用户组管理及权限管理"></a>用户、用户组管理及权限管理</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p><strong><code>添加用户</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd xiaoming                     #创建用户成功后，会自动的创建和用户同名的家目录 </span><br><span class="line">useradd -d /home/dog xiaoming        #给新创建的用户创建家目录</span><br></pre></td></tr></table></figure><p><strong><code>给用户分配密码</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd xiaoming </span><br></pre></td></tr></table></figure><p><strong><code>删除用户</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel xiaoming                    #删除用户，但是保留家目录</span><br><span class="line">userdel -r xiaoming                 #删除用户并且删除家目录</span><br></pre></td></tr></table></figure><p><strong><code>查询用户信息</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id root</span><br><span class="line">&gt;&gt;uid=0(root)                        #用户id号</span><br><span class="line">&gt;&gt;gid=0(root)       #所在组的id号</span><br><span class="line">&gt;&gt;组=0(root) #组名</span><br></pre></td></tr></table></figure><p><strong><code>切换用户</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">su xiaoming</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong><code>查看文件的所有者</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ahl</span><br></pre></td></tr></table></figure><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd groupname</span><br><span class="line">groupdel groupname</span><br><span class="line">useradd -g groupname username#创建用户的时候增加组</span><br><span class="line">usermod -g groupname username#修改组</span><br></pre></td></tr></table></figure><h3 id="文件的所有者和所在组"><a href="#文件的所有者和所在组" class="headerlink" title="文件的所有者和所在组"></a>文件的所有者和所在组</h3><p><strong><code>修改文件的所有者</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown tom apple.txt</span><br></pre></td></tr></table></figure><p><strong><code>修改文件所在的组</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#当用户创建了一个文件之后，默认这个文件的所在组就是该用户所在的组</span><br><span class="line">chgrp 组名 文件名</span><br></pre></td></tr></table></figure><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Is -l中显示的内容如下：</span><br><span class="line">-rwxrw-r— 1 root root 1213 Feb 2 09:39 abc</span><br><span class="line">0-9位说明</span><br><span class="line">1）第0位确定文件类型（d,-,第c, b）</span><br><span class="line">2）第1-3位确定所有者（该文件的所有者）拥有该文件的权限。一User</span><br><span class="line">3）第4-6位确定所属组（同用户组的）拥有该文件的权限，一Group</span><br><span class="line">4）第7-9位确定其他用户拥有该文件的权限一Other</span><br></pre></td></tr></table></figure><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>**<code>第一种方式：+ 、 - 、 =变更权限</code> **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u:所有者g:所在组o:其他人a:所有人</span><br><span class="line">chmod u=rwx,g=rx,o=x 文件目录名</span><br><span class="line">chmod o+w 文件目录名</span><br><span class="line">chmod a-x 文件目录名</span><br></pre></td></tr></table></figure><p><strong><code>通过数字权限变更</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 751 文件目录名</span><br></pre></td></tr></table></figure><h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] newowner  file   #改变文件的所有者(如果是目录，则可以用-R对其所有的子文件递归生效)</span><br></pre></td></tr></table></figure><h3 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] newgroup file</span><br></pre></td></tr></table></figure><h2 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h2><h3 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h3><p><strong>gzip</strong> : 将文件压缩成.*gz文件(不会保留原来的文件)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip hello.txt</span><br></pre></td></tr></table></figure><p><strong>gunzip</strong> : 解压缩文件命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip hello.txt.gz</span><br></pre></td></tr></table></figure><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><p><strong>zip</strong> : 压缩文件和目录</p><p><code>-r : 递归压缩,即压缩目录</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r mypackage.zip /home/*</span><br></pre></td></tr></table></figure><p><strong>unzip</strong> : 解压缩文件</p><p><code>-d &lt;dest&gt; : 指定压缩后文件的存放目录</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -d /opt/tmp/ mypackage.zip</span><br></pre></td></tr></table></figure><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-z</td><td>打包同时压缩</td></tr><tr><td align="center">-c</td><td>产生.tar打包文件</td></tr><tr><td align="center">-x</td><td>解包.tar文件</td></tr><tr><td align="center">-v</td><td>显示详细信息</td></tr><tr><td align="center">-f</td><td>指定压缩后的文件名</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#case1 : 压缩多个文件,将/home/a1.txt和/home/a2.txt压缩成a.tar.gz</span><br><span class="line">tar -zcvf a.tar.gz a1.txt a2.txt</span><br><span class="line"></span><br><span class="line">#case2 : 将/home文件夹压缩成 myhome.tar.gz</span><br><span class="line">tar -zcvf myhome.tar.gz /home/*</span><br><span class="line"></span><br><span class="line">#case3 : 将a.tar.gz 解压到当前目录</span><br><span class="line">tar -zxvf a.tar.gz</span><br><span class="line"></span><br><span class="line">#case4 : 将myhome.tar.gz 解压到/opt/目录下(该目录必须存在)</span><br><span class="line">tar -zxvf myhome.tar.gz -C /opt/</span><br></pre></td></tr></table></figure><h2 id="指令运行级别"><a href="#指令运行级别" class="headerlink" title="指令运行级别"></a>指令运行级别</h2><p><strong><code>找回root密码</code></strong></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="查看进程及指令说明"><a href="#查看进程及指令说明" class="headerlink" title="查看进程及指令说明"></a>查看进程及指令说明</h4><h5 id="ps指令查看进程"><a href="#ps指令查看进程" class="headerlink" title="ps指令查看进程"></a>ps指令查看进程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep xxx</span><br><span class="line">ps -aux | grep sshd#查看有没有sshd服务</span><br><span class="line"></span><br><span class="line">pstree [选项]   #用树形结构显示进程信息</span><br><span class="line">-p : 显示进程的PID</span><br><span class="line">-u : 显示进程的所属用户</span><br></pre></td></tr></table></figure><p><strong>指令说明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">•System V展示风格</span><br><span class="line">•USER：用户名称</span><br><span class="line">•PID：进程号</span><br><span class="line">•%CPU：进程占用CPU的百分比</span><br><span class="line">•%MEM：进程占用物理内存的百分比</span><br><span class="line">•VSZ：进程占用的虚拟内存大小（单位：KB）</span><br><span class="line">•RSS：进程占用的物理内存大小（单位：KB）</span><br><span class="line">•TT：终端名称，缩写.</span><br><span class="line">•STAT：进程状态，其中S-睡眠，S-表示该进程是会话的先导进程，N-表示进程拥有比普通优先 文更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</span><br><span class="line">•STARTED：进程的启动时间</span><br><span class="line">•TIME：CPU时间，即进程使用CPU的总时间</span><br><span class="line">•COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/27/IoTKDhkJANCq5M3.png" alt="image-20211127173615213.png"></p><p><strong>全格式显示当前所有进程,查看父进程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | more#以全格式显示当前所有的进程</span><br><span class="line">-e显示所有的进程</span><br><span class="line">-f全格式</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">•是BSD风格</span><br><span class="line">•UID：用户 ID</span><br><span class="line">•PID：进程 ID</span><br><span class="line">•PPID：父进程ID</span><br><span class="line">•c： CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会 降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高</span><br><span class="line">•STIME：进程启动的时间</span><br><span class="line">•TTY：完整的终端名称</span><br><span class="line">•TIME： CPU 时间</span><br><span class="line">•CMD：启动进程所用的命令和参数</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/27/dPGIeBfj1Oy9pSX.png" alt="Snipaste_2021-11-27_17-53-45.png"></p><h5 id="top指令动态监控进程"><a href="#top指令动态监控进程" class="headerlink" title="top指令动态监控进程"></a>top指令动态监控进程</h5><p>top指令和ps指令最大的不同之处在于,top在执行一段时间后可以更新正在运行的进程</p><p><code>top [选项]</code></p><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-d 秒数</td><td align="center">指定top命令每隔几秒更新.默认是3秒,在top命令的交互模式当中可执行的命令</td></tr><tr><td align="center">-i</td><td align="center">使top不现实任何闲置或者僵死进程</td></tr><tr><td align="center">-p</td><td align="center">通过指定监控进程ID来仅仅监控某个进程的状态</td></tr><tr><td align="center">P</td><td align="center">以CPU使用率排序(默认)</td></tr><tr><td align="center">M</td><td align="center">以内存使用率排序</td></tr><tr><td align="center">N</td><td align="center">以PID排序</td></tr></tbody></table><p><em>case1:监视特定用户</em> : <code>top;u username;</code></p><p><em>case2:终止指定的进程</em> :<code>top;k PID</code>;</p><h4 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h4><p><code>kill [选项] PID</code>  :  通过进程号杀死进程</p><p><code>kill 进程名称</code> : 通过进程名杀死进程,也支持通配符,这在系统因负载过大而变得很慢的时候很有用</p><p> <em>case1 : 踢掉某个非法用户登录</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep sshd</span><br><span class="line">kill 4010</span><br></pre></td></tr></table></figure><p><em>case2 : 终止远程登录服务sshd,在适当时候再次重启sshd服务</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep sshd</span><br><span class="line">&gt;3908………  /user/sbin/sshd</span><br><span class="line">kill 3908</span><br></pre></td></tr></table></figure><p><em>case3 : 终止多个gedit编辑器</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall gedit</span><br></pre></td></tr></table></figure><p><em>case 4 : 强制杀掉一个终端</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#终端 : /bin/bash</span><br><span class="line">ps -aux | grep bash</span><br><span class="line">kill -9 4115</span><br></pre></td></tr></table></figure><h3 id="服务-守护进程"><a href="#服务-守护进程" class="headerlink" title="服务(守护进程)"></a>服务(守护进程)</h3><h4 id="service管理指令"><a href="#service管理指令" class="headerlink" title="service管理指令"></a>service管理指令</h4><p><strong>服务本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如（mysql，sshd，防火墙），因此我们又称为守护进程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [start|stop|restart|reload|status]</span><br><span class="line">在CentOS7.0后，不在使用service，而是systemctl</span><br></pre></td></tr></table></figure><p><em>case1 : 查看当前防火墙的状态，关闭防火墙和重启防火墙</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service iptable status</span><br><span class="line">service iptable stop</span><br><span class="line">service iptable start</span><br><span class="line">#关闭或者启用防火墙后,立即生效</span><br><span class="line">#这种方式只是临时生效,当重启系统之后,还是回归到对以前该服务的设置</span><br><span class="line">#如果希望设置某个服务自动启动或者关闭永久生效,要用chkconfig指令</span><br></pre></td></tr></table></figure><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h4><p><code>setup</code> : 查看服务名(虚拟机中)</p><p><code>/etc/init.d</code> : <code>ls -l /etc/init.d</code></p><h4 id="服务的运行级别-runlevel"><a href="#服务的运行级别-runlevel" class="headerlink" title="服务的运行级别(runlevel)"></a>服务的运行级别(runlevel)</h4><p>查看或者修改默认级别：<code>vi/etc/mittab</code><br>Linux系统有7种运行级别（runlevel）：常用的是级别<strong>3</strong>和<strong>5</strong></p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">运行级别0</td><td align="center">系统停机状态，系统默认运行级别不能设为0,否则不能正常启动</td></tr><tr><td align="center">运行级别1</td><td align="center">单用户工作状态，root权限，用于系统维护，禁止远程登陆</td></tr><tr><td align="center">运行级别2</td><td align="center">多用户状态（没有NFS）,不支持网络</td></tr><tr><td align="center">运行级别3</td><td align="center">完全的多用户状态（有NFS）,登陆后进入控制台命令行模式</td></tr><tr><td align="center">运行级别4</td><td align="center">系统未使用，保留</td></tr><tr><td align="center">运行级别5</td><td align="center">X11控制台，登陆后进入图形GUI模式</td></tr><tr><td align="center">运行级别6</td><td align="center">系统正常关闭并重启，默认运行级别不能设为6,否则不能正常启动</td></tr></tbody></table><h4 id="chkconfig指令"><a href="#chkconfig指令" class="headerlink" title="chkconfig指令"></a>chkconfig指令</h4><p>通过chkconfig指令可以给每个服务的各个运行级别设置自启动/关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list</span><br><span class="line">chkconfig --list | grep sshd</span><br><span class="line">chkconfig --level 5 服务名 on/off       #把该服务runlevel=5设置为on/off</span><br><span class="line">chkconfig 服务名 on/off</span><br><span class="line">#chkconfig重新设置服务自启动或关闭,需要重启及其reboot才能生效</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/27/aku8KPJohOD6NCG.png" alt="Snipaste_2021-11-27_22-38-02.png"></p><h4 id="查看系统网络情况-netstat"><a href="#查看系统网络情况-netstat" class="headerlink" title="查看系统网络情况 netstat"></a>查看系统网络情况 netstat</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br><span class="line">-an 按照一定顺序排列输出</span><br><span class="line">-p  显示哪个进程在调用</span><br><span class="line">netstat -anp | grep sshd#查看服务名为sshd的系统网络信息</span><br></pre></td></tr></table></figure><h2 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h2><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab [ ]"></a>crontab [ ]</h4><p>任务调度 ：是指系统在某个时间执行的特定的命令或程序</p><p>任务调度分类：</p><pre><code> 1. 系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等 2. 个别用户工作：如对mysql数据库的备份</code></pre><p><code>crontab [选项]</code></p><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">编辑crontab定时任务</td></tr><tr><td align="center">-l</td><td align="center">查询crontab任务</td></tr><tr><td align="center">-r</td><td align="center">删除当前用户所有的crontab任务</td></tr><tr><td align="center">service crond restart</td><td align="center">重启任务调度</td></tr></tbody></table><p><em>Example：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#每分钟都自动调用ls -l /etc&gt;&gt;/tmp/to.txt</span><br><span class="line">crontab -e</span><br><span class="line">*/1 * * * * ls -l /etc&gt;&gt;/tmp/to.txt</span><br><span class="line">保存退出</span><br><span class="line"></span><br><span class="line">#每分钟当当前日期和日历都追加到/home/mycal文件中</span><br><span class="line">先编写一个文件 /home/mytask2.sh</span><br><span class="line">1. date&gt;&gt;/tmp/mycal    cal&gt;&gt;/tmp/mycal</span><br><span class="line">2. chmod 744 /home/mytask2.sh</span><br><span class="line">3. crontab -e</span><br><span class="line">4. */1 * * * * /home/mytask2.sh</span><br></pre></td></tr></table></figure><p><em>参数细节</em></p><table><thead><tr><th>参数</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个*</td><td>一小时当中有几分钟</td><td>0-59</td></tr><tr><td>第二个*</td><td>一天中有几个小时</td><td>0-23</td></tr><tr><td>第三个*</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第四个*</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td>第五个*</td><td>一周当中的星期几</td><td>0-7(0和7都代表星期日)</td></tr></tbody></table><p><em>特殊符号的说明</em></p><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任意时间。比如每个小时，每分钟</td></tr><tr><td>，</td><td>代表不连续的时间。比如“0 8,12,13 * * * ”代表每天的八点0分,12点0分,13点分执行一次命令</td></tr><tr><td>-</td><td>代表连续的时间范围</td></tr><tr><td>*/n</td><td>代表每个n执行一次命令</td></tr></tbody></table><p><code>case1 : */10 4 15 * *</code> : 每月15号的4点每隔10分钟执行一次命令 </p><h2 id="RPM和YUM"><a href="#RPM和YUM" class="headerlink" title="RPM和YUM"></a>RPM和YUM</h2><h3 id="RPM-RedHat-Package-Manager"><a href="#RPM-RedHat-Package-Manager" class="headerlink" title="RPM(RedHat Package Manager)"></a>RPM(RedHat Package Manager)</h3><h4 id="rpm包的查询"><a href="#rpm包的查询" class="headerlink" title="rpm包的查询"></a>rpm包的查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -q XXX #查询软件包是否安装</span><br><span class="line">rpm -qa | grep XXX #查看所有安装的rpm包</span><br><span class="line">rpm -qi XXX  #查询软件包信息</span><br><span class="line">rpm -ql XXX #查询软件包中的文件</span><br><span class="line">rpm -qf 文件路径  #查询文件所属于哪个rpm包</span><br></pre></td></tr></table></figure><p>rpm包的基本格式 : firefox-45.0.1-1.el6.centos.x86_64.rpm</p><ul><li>名称:firefox</li><li>版本号:45.0.1-1</li><li>适用的操作系统:el6.centos.x86_64(noarch表示通用) </li></ul><h4 id="rpm包的卸载"><a href="#rpm包的卸载" class="headerlink" title="rpm包的卸载"></a>rpm包的卸载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e XXX</span><br><span class="line">rpm -e --npdeps XXX#强制删除(无论该文件是否是另一文件的依赖包)</span><br></pre></td></tr></table></figure><h4 id="rpm包的安装"><a href="#rpm包的安装" class="headerlink" title="rpm包的安装"></a>rpm包的安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh XXX</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">安装</td></tr><tr><td align="center">-v</td><td align="center">提示</td></tr><tr><td align="center">-h</td><td align="center">进度条</td></tr></tbody></table><h3 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h3><p>yum是一个shell前端软件管理器。基于RPM包管理，能够从指定的服务器自动下载rpm包并且安装，可以制动处理依赖性关系，并且一次性安装所有依赖的软件包。需要联网。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep XXX#查询是否有该rpm包</span><br><span class="line">yum install XXX</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法：#Leecode435无重叠区间</title>
      <link href="/2021/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode435%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
      <url>/2021/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode435%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法：-Leecode435无重叠区间"><a href="#贪心算法：-Leecode435无重叠区间" class="headerlink" title="贪心算法：#Leecode435无重叠区间"></a>贪心算法：#Leecode435无重叠区间</h1><h2 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><h2 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h2><p>先计算最多能组成多少不重叠的区间，然后用总区间个数减去不重叠区间的个数。</p><p>每次都要选择一个区间结尾最小的，这样留给后面的空间就越大，那么后面能够选的区间的个数就越多。</p><p>由于每个区间都是start&lt;end的，所以利用lamda表达式把所有的区间按照尾排序。</p><p>lamda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>() , intervals.<span class="built_in">end</span>() , [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;u , <span class="keyword">const</span> <span class="keyword">auto</span> &amp;v)&#123;<span class="comment">//如果把auto改成&lt;vector&gt;int类型会快很多</span></span><br><span class="line"><span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; u, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> edge = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= edge)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                edge = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="贪心算法：-Leecode452扎气球"><a href="#贪心算法：-Leecode452扎气球" class="headerlink" title="贪心算法：#Leecode452扎气球"></a>贪心算法：#Leecode452扎气球</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p> 示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>() , points.<span class="built_in">end</span>() , [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp;u , <span class="keyword">const</span> <span class="keyword">auto</span>&amp;v)&#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endrange = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(endrange &gt;= points[i][<span class="number">0</span>])&#123;       <span class="comment">//如果气球有重叠，那么不用管，一根箭就可以戳爆了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            endrange = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针#LeeCode680验证回文字符串Ⅱ</title>
      <link href="/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode680%E9%AA%8C%E8%AF%81%E4%BC%9A%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1/"/>
      <url>/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode680%E9%AA%8C%E8%AF%81%E4%BC%9A%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针-：-LeeCode680验证回文字符串Ⅱ"><a href="#双指针-：-LeeCode680验证回文字符串Ⅱ" class="headerlink" title="双指针 ： #LeeCode680验证回文字符串Ⅱ"></a>双指针 ： #LeeCode680验证回文字符串Ⅱ</h1><h2 id="题目重述："><a href="#题目重述：" class="headerlink" title="题目重述："></a>题目重述：</h2><p>给定一个非空字符串s，最多删除一个字符，判断是否能够成为回文字符串</p><p>实例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abca&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure><p>实例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>自己的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//这里显得多少有带你幼稚了。而且错误出现在这里</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>] == s[j] )&#123;</span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == s[j<span class="number">-1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思考：不用总是使用count等辅助变量。试试其他的思路！</p><p>关键：只允许失误一次</p><p>题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">length</span>()<span class="number">-1</span> ; i &lt;= j ; i++  ,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])&#123;<span class="comment">//唯一一次的失误机会</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isPalindrome</span>(s , i+<span class="number">1</span> , j) || <span class="built_in">isPalindrome</span>(s , i , j<span class="number">-1</span>);<span class="comment">//判断跳过左右两个字符是否会成为回文</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s , <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i++] != s[j--])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针#LeeCode524通过删除字母匹配到字典里最长单词</title>
      <link href="/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode524%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"/>
      <url>/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode524%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针：-LeeCode524通过删除字母匹配到字典里最长单词"><a href="#双指针：-LeeCode524通过删除字母匹配到字典里最长单词" class="headerlink" title="双指针：#LeeCode524通过删除字母匹配到字典里最长单词"></a>双指针：#LeeCode524通过删除字母匹配到字典里最长单词</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。</p><p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abpcplea&quot;, dictionary = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abpcplea&quot;, dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>自己的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;string&gt; save;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;<span class="comment">//1</span></span><br><span class="line">             <span class="keyword">int</span> pointer1 = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> pointer2 = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">while</span>(pointer1 != n)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(s[pointer1++] == dictionary[i][pointer2])&#123;</span><br><span class="line">                     pointer2++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(pointer2 == dictionary[i].<span class="built_in">length</span>())&#123;</span><br><span class="line">                save.<span class="built_in">push_back</span>(dictionary[i]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(save.<span class="built_in">begin</span>() == save.<span class="built_in">end</span>())&#123;<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">            string temp = save[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;save.<span class="built_in">size</span>();i++)&#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">if</span>(save[i] &lt; save[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    temp = save[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>1、2两处使用了两次循环。但是，这是两个完全相统的循环。所以是否可以只使用一次循环就完成？</p><p>3处的判断过于冗余</p><p>题解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String t : dictionary)&#123;</span><br><span class="line">            <span class="keyword">int</span> pointer1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> pointer2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pointer1 &lt; s.length() &amp;&amp; pointer2 &lt; t.length())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(pointer1++) == t.charAt(pointer2))&#123;</span><br><span class="line">                    pointer2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pointer2 == t.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.length() &gt; res.length() || ( t.length() == res.length() &amp;&amp; t.compareTo(res) &lt; <span class="number">0</span>))&#123;</span><br><span class="line">                    res = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快慢双指针#LeeCode141环形链表</title>
      <link href="/2021/11/24/%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/24/%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="快慢双指针：-LeeCode141环形链表"><a href="#快慢双指针：-LeeCode141环形链表" class="headerlink" title="快慢双指针：#LeeCode141环形链表"></a>快慢双指针：#LeeCode141环形链表</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>示例1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><h2 id="题解：Floyd判圈法"><a href="#题解：Floyd判圈法" class="headerlink" title="题解：Floyd判圈法"></a>题解：Floyd判圈法</h2><p>算法思想：假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;<span class="comment">//判断条件是两个何时相等</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)&#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;<span class="comment">//每次走一格</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;<span class="comment">//每次走两格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1：巧用或运算。先判断前件，如果前件不满足，则直接不考虑后件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2021/11/24/Git/"/>
      <url>/2021/11/24/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="工作区，暂存区，本地库"><a href="#工作区，暂存区，本地库" class="headerlink" title="工作区，暂存区，本地库"></a>工作区，暂存区，本地库</h1><h2 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init//在某个文件夹内执行该指令，该文件夹就会成为本地的workspace</span><br></pre></td></tr></table></figure><p>git init生成.git文件，是隐藏文件，如果需要访问需要<code>ls -lA</code>。</p><p>.git目录中存放的是本地库相关的子目录和文件，不要乱动</p><h3 id="设置签名-：-区分不同开发人员的身份（和登录远程库的账号密码无关）"><a href="#设置签名-：-区分不同开发人员的身份（和登录远程库的账号密码无关）" class="headerlink" title="设置签名 ： 区分不同开发人员的身份（和登录远程库的账号密码无关）"></a>设置签名 ： 区分不同开发人员的身份（和登录远程库的账号密码无关）</h3><p>项目级别/仓库级别：仅在当前工作区有效</p><p>系统用户级别：当前操作系统的用户范围</p><p>项目级别优先于系统用户级别，如果没有项目级别就是用系统用户级别的签名</p><p>查看签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config -l             //所有的配置 = system+global</span><br><span class="line">git config --system --list    //系统配置</span><br><span class="line">git config --global --list    //全局配置，用户自己的配置</span><br></pre></td></tr></table></figure><p>配置签名： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;liyuan&quot;</span><br><span class="line">git config user.email &quot;liyuan_sunny@163.com&quot;//保存在./.git/config文件中</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;liyuan&quot;</span><br><span class="line">git config --gloabl user.email &quot;liyuan_sunny@163.com&quot;   //保存在~/.gitconfig</span><br></pre></td></tr></table></figure><h3 id="配置ssh免密登录"><a href="#配置ssh免密登录" class="headerlink" title="配置ssh免密登录"></a>配置ssh免密登录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">rm -rf .ssh</span><br><span class="line">ssh-keygen -t rsa -C liyuan_sunny@163.com</span><br><span class="line">cd .ssh</span><br><span class="line">cat id_isa.pub</span><br><span class="line">复制公钥，到github</span><br><span class="line">git remote add origin_ssh git@…………</span><br><span class="line">git push origin_ssh helloworld.cpp</span><br></pre></td></tr></table></figure><h3 id="SSL验证错误"><a href="#SSL验证错误" class="headerlink" title="SSL验证错误"></a>SSL验证错误</h3><p>在提交的时候遇到了报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/LYinGithub/hello-world.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>解决方法：但是每次push都需要这么一串代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status //查看当前工作区、暂存区的状态</span><br><span class="line">vim helloworld.txt  //创建一个未追踪的文件</span><br><span class="line">git add &lt;文件名&gt;   //只能用git add将本地未追踪的文件添加到暂存区</span><br><span class="line">git rm --cached &lt;文件名&gt;    //将暂存区的取回</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>快照流。提交没有变的部分是提供一个指向上一个对象的指针，存储差异。考虑到git的轻量级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit &lt;文件名&gt;          //暂存区的修改提交到本地库。</span><br><span class="line">git commit -m &quot;注释&quot; &lt;文件名&gt; //当场写注释</span><br></pre></td></tr></table></figure><p>如果修改该文件已追踪的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//第一次提交</span><br><span class="line">vim helloworld.txt;</span><br><span class="line">git add helloworld.txt;</span><br><span class="line">git commit -m &quot;the first test&quot; helloworld.txt</span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">vim helloworld.txt</span><br><span class="line"></span><br><span class="line">//第二次提交</span><br><span class="line">git add + git commit -m //由于已经追踪过该文件，所以可以用git add添加到暂存区，也可以直接commit</span><br><span class="line">git commit -a</span><br><span class="line">(git reset HEAD helloworld.txt)//可以使用这个命令从暂存区取回</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="git-log-：-查看当前本地库的提交记录"><a href="#git-log-：-查看当前本地库的提交记录" class="headerlink" title="git log ： 查看当前本地库的提交记录"></a>git log ： 查看当前本地库的提交记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log                    //空格向下翻页，b向上翻页，q退出</span><br><span class="line">git log --pretty=oneline   //每个日志只显示一行</span><br><span class="line">git log --oneline</span><br><span class="line">git reflog                 //查看回退到各个版本HEAD指针需要走几步</span><br></pre></td></tr></table></figure><h3 id="git-reset-git-revert撤销变更"><a href="#git-reset-git-revert撤销变更" class="headerlink" title="git reset/git revert撤销变更"></a>git reset/git revert撤销变更</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard hashindex//前进后退都行       HEAD^^//本地</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD~100//回滚100个版本（~num &amp;&amp; ^ 的相对引用）</span><br><span class="line">git reset --hart HEAD^^  //回滚2个版本</span><br><span class="line"></span><br><span class="line">git revert //云端</span><br></pre></td></tr></table></figure><p>–soft参数 ： 仅仅是在本地库移动HEAD指针（会显得缓存区的文件出现了修改。其实实际上没有改，是因为本地库回滚，看样子暂存区修改了）</p><p>–mixed参数：在本地库移动HEAD指针，并且重置暂存区（会显得工作区的文件出现了修改）</p><p>–hard参数：移动本地库的HEAD指针，重置暂存区，重置工作区</p><h3 id="rm-lt-filename-gt"><a href="#rm-lt-filename-gt" class="headerlink" title="rm &lt;filename&gt;"></a>rm &lt;filename&gt;</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;filename&gt; //删除这个文件，通常指的是提交到本地库之后删除这个文件</span><br><span class="line">rm helloworld.txt</span><br><span class="line">ll              //发现工作区已经没有这个文件了</span><br><span class="line">git add helloworld.txt    //把删除helloworld.txt的这条指令添加到暂存区</span><br><span class="line">git commit -m &quot;hhh&quot; helloworld.txt;</span><br><span class="line">git status               //发现工作区和缓存区清空</span><br><span class="line">git reset HEAD^              //可以通过上一个版本找回这个文件</span><br></pre></td></tr></table></figure><p>如果已经把删除的指令提交到暂存区，但是还没提交到本地库。怎么取回这条操作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD;</span><br></pre></td></tr></table></figure><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld.txt             </span><br><span class="line">git diff                    //无其他参数：和暂存区比较</span><br><span class="line">git diff HEAD helloworld.txt   //和本地库比较</span><br><span class="line">git diff HEAD^^                //和本地库的前几个版本比较</span><br></pre></td></tr></table></figure><h3 id="git-tag-git-describe………………（用到再说）"><a href="#git-tag-git-describe………………（用到再说）" class="headerlink" title="git tag / git describe………………（用到再说）"></a>git tag / git describe………………（用到再说）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1 C1//为C1创建一个名叫V1的标签</span><br><span class="line">git describe//返回距离最近标签之间的版本差距信息</span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v               //查看所有分支名</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch bugFix//创建一个名叫bugFix的分支，内容是从master分支复制而来</span><br><span class="line">git branch -b bugFix C1//在C1处创建一个名叫bugFix的分支并且使指针指向他</span><br><span class="line">git branch -f main HEAD//强制将main指针移动到HEAD指针所在的位置，这个不一定是指针，也可以是任意一个提交版本的位置，这个命令就是操控分支指针的命令</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout bugFix//当前在bugFix分支</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>git merge能有有效的保护历史</p><ol><li>切换到接受修改的分支（被合并，增加新内容）</li><li>执行merge命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge bugFix//目前指针在m。main吸收main和bugFix两个分支，之后指针仍然指向main</span><br></pre></td></tr></table></figure><h4 id="git-merge-git-rebase-git-cherry-pick（未实战）"><a href="#git-merge-git-rebase-git-cherry-pick（未实战）" class="headerlink" title="git merge/git rebase/git cherry-pick（未实战）"></a>git merge/git rebase/git cherry-pick（未实战）</h4><p>git rebase能够让整个项目看起来极其线性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git rebase main//目前指针在bugFix，将bugFix复制到main的新的提交，之后指针仍然指向bugFix </span><br><span class="line">//bugFix原来的分支仍然存在</span><br><span class="line"></span><br><span class="line">git rebase bugFix//因为此时bugFix指向main，所以git知识简单的把main分支的引用向前移动了一下</span><br><span class="line"></span><br><span class="line">git rebase -i HEAD~4//出现UI窗口，你可以决定如何复制</span><br><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>git cherry-pick实现自由复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick C1 C2 C3;</span><br></pre></td></tr></table></figure><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p> 冲突内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaaaa</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD   /*</span><br><span class="line">hhhhhhhhhhhh当前分支得到内容</span><br><span class="line">=============     *//*另一分支的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;master*/</span><br><span class="line">iiiiiiiiiiiii</span><br><span class="line">jjjjjjjjjjjj</span><br></pre></td></tr></table></figure><p>解决冲突 ： 删除掉字符就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld.txt          //删除掉不需要的东西</span><br><span class="line">git add helloworld.txt                  //使用git add标志文件为已解决。此时所有冲突都被解决，但是仍然没有合并</span><br><span class="line">git commit -m &quot;ok merge&quot;                //不带文件名</span><br></pre></td></tr></table></figure><h1 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h1><h2 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote -v       //查看本地现有的地址别名</span><br><span class="line">git remote add origin https://github.com/LYinGithub/hello-world.git  //给这串地址取别名为origin</span><br></pre></td></tr></table></figure><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><ol><li>完整的把远程库下载到本地</li><li>创建origin远程地址别名</li><li>初始化本地库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LYinGithub/hello-world.git</span><br></pre></td></tr></table></figure><h3 id="git-Push"><a href="#git-Push" class="headerlink" title="git Push"></a>git Push</h3><p>将当前分支推送到云端仓库。</p><p>远程仓库接收到了更新，远程仓库的main指向新的更新，同时我们的远程分支<code>origin/main</code>也同时更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git Push</span><br></pre></td></tr></table></figure><h4 id="git-push的参数-1-：-git-push-lt-remote-gt-lt-place-gt"><a href="#git-push的参数-1-：-git-push-lt-remote-gt-lt-place-gt" class="headerlink" title="git push的参数 1 ： git push  &lt;remote&gt; &lt;place&gt;"></a>git push的参数 1 ： git push  &lt;remote&gt; &lt;place&gt;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main(指定place参数,即要推送的分支)</span><br></pre></td></tr></table></figure><p>翻译过来就是：<strong>切换到本地仓库的“main”</strong>，获取所有的提交，再到远程仓库”orirgin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去</p><p>如果不指定参数会发生什么?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout C0</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>什么也不会发生，因为我们所检出的HEAD没有跟踪任何分支</p><h4 id="git-push的参数2：git-push-origin-lt-source-gt-lt-destination-gt"><a href="#git-push的参数2：git-push-origin-lt-source-gt-lt-destination-gt" class="headerlink" title="git push的参数2：git push origin &lt;source&gt; &lt;destination&gt;"></a>git push的参数2：git push origin &lt;source&gt; &lt;destination&gt;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin f00^:main//把本地库的foo的父提交推送到远端仓库的main分支中</span><br></pre></td></tr></table></figure><p>如果要推送的分支不存在会怎么样？git会在你远程仓库中根据提供的名称创建这个分支</p><p>同时本地也会在提交的节点创建origin/newBranch远程分支追踪远程仓库中的newBranch分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main:newBranch</span><br></pre></td></tr></table></figure><h4 id="git-push的参数3：奇怪的-lt-source-gt"><a href="#git-push的参数3：奇怪的-lt-source-gt" class="headerlink" title="git push的参数3：奇怪的&lt;source&gt;"></a>git push的参数3：奇怪的&lt;source&gt;</h4><p>通过push传控制source，可以删除远程仓库中的side分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :side</span><br></pre></td></tr></table></figure><h4 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h4><p>必须基于远程库的最新分支才能够push，否则会被git决绝请求—-&gt;使用rebase调整本地库的工作</p><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase origin/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>需要更新本地仓库的远程分支，然后用rebase将我们的工作移动到最新的提交记录，然后再用git push推送到远程仓库</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>将远程仓库的更新下载到本地，但是不修改本地文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch//把远程仓库的更新下载到本地，同时远程分支origin/main也被更新，然而原本的main不会改变</span><br></pre></td></tr></table></figure><h4 id="git-fetch的参数1：与git-push十分相似，知识方向相反罢了"><a href="#git-fetch的参数1：与git-push十分相似，知识方向相反罢了" class="headerlink" title="git fetch的参数1：与git push十分相似，知识方向相反罢了"></a>git fetch的参数1：与git push十分相似，知识方向相反罢了</h4><p>在远程仓库的<code>foo</code>分支上，获取所有本地不存在的提交，放到本地的origin/foo上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br><span class="line">git checkout origin/foo</span><br><span class="line">cat helloworld.txt         //可以看到本地库里helloworld的变化了</span><br></pre></td></tr></table></figure><p>问：为什么不是将git放到本地的<code>foo</code>分支（及抓取后将文件放在本地库，但是没有修改工作区的文件）</p><p>答：因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 <code>git fetch</code> 课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）</p><h4 id="git-fetch的参数2："><a href="#git-fetch的参数2：" class="headerlink" title="git fetch的参数2："></a>git fetch的参数2：</h4><p>git将<code>foo~1</code>解析成一个origin的仓库位置，然后将那些提交记录下载到本地的bar（存在）分支，注意由于制定了目标分支，我们其他的分支都没有被更新</p><p>注：如果本地的bar分支不存在怎么办？git会创建一个bar分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo~1:bar</span><br></pre></td></tr></table></figure><h4 id="git-fetch没有参数："><a href="#git-fetch没有参数：" class="headerlink" title="git fetch没有参数："></a>git fetch没有参数：</h4><p>如果<code>git fetch</code>没有参数，它会下载所有的提交记录到各个远程分支</p><h4 id="git-fetch参数4：奇怪的-lt-source-gt"><a href="#git-fetch参数4：奇怪的-lt-source-gt" class="headerlink" title="git fetch参数4：奇怪的&lt;source&gt;"></a>git fetch参数4：奇怪的&lt;source&gt;</h4><p>fetch一个空source到本地，会在本地创建一个新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin :bugFix</span><br></pre></td></tr></table></figure><h3 id="git-Pull-git-fetch-git-merge"><a href="#git-Pull-git-fetch-git-merge" class="headerlink" title="git Pull = git fetch + git merge"></a>git Pull = git fetch + git merge</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull = git fetch + git merge origin/main</span><br></pre></td></tr></table></figure><p>注意：git pull必须基于本地remote tracking branch</p><p>否则git pull –rebase会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">side3 is not a remote tracking branch!I don&#x27;t know where to pull</span><br></pre></td></tr></table></figure><h4 id="git-pull的参数"><a href="#git-pull的参数" class="headerlink" title="git pull的参数"></a>git pull的参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin foo = git fetch origin foo</span><br><span class="line">git merge origin/foo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin bar~1:bugFix = git feetch origin bar~1:bugFix</span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure><h2 id="远程追踪分支：origin-main与remote-tracking"><a href="#远程追踪分支：origin-main与remote-tracking" class="headerlink" title="远程追踪分支：origin/main与remote tracking"></a>远程追踪分支：origin/main与remote tracking</h2><h3 id="关于origin-main"><a href="#关于origin-main" class="headerlink" title="关于origin/main"></a>关于origin/main</h3><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout origin/main</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>HEAD会直接变成分离状态。而origin/main不会更新。</p><p>由于remote tracking机制的存在，main背设定为追踪origin/main，这意味着main分支制定了推送的目的地以及拉去后合并的目标</p><h3 id="自定义追踪origin-main-：-git-checkout-b-branchname-origin-main"><a href="#自定义追踪origin-main-：-git-checkout-b-branchname-origin-main" class="headerlink" title="自定义追踪origin/main ： git checkout -b branchname origin/main"></a>自定义追踪origin/main ： git checkout -b branchname origin/main</h3><p>可以自定义任意分支追踪origin/main，然后分支就会像main分支一样隐含的push目的地以及merge的目标。</p><p>//创建一个名为totalNotMain分支，然后追踪远程分支origin/main ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b tootalNotMain origin/main</span><br></pre></td></tr></table></figure><p>//pull : 使用foo来追踪origin/main，在pull之后，foo会跟随origin/main更新，然而main没有被更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo origin/main</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>//push：由于git checkout -b foo本身就是创建一个分支，然后使指针指向他。所以提交之后main不会更改，而foo会更改</p><p>//push之后origin/main会到达foo的位置，而main会停留在原地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo origin/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="自定义追踪-：-git-branch-u"><a href="#自定义追踪-：-git-branch-u" class="headerlink" title="自定义追踪 ： git branch -u"></a>自定义追踪 ： git branch -u</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/main foo</span><br></pre></td></tr></table></figure><p>如果当前节点在foo上，那么还可以省略foo ： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/main</span><br></pre></td></tr></table></figure><h1 id="git跨团队协作"><a href="#git跨团队协作" class="headerlink" title="git跨团队协作"></a>git跨团队协作</h1><h2 id="邀请加入团队"><a href="#邀请加入团队" class="headerlink" title="邀请加入团队"></a>邀请加入团队</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. repository-&gt;setting-&gt;collaborators+被邀请人的GitHub账号</span><br><span class="line">2. 复制链接，发送给那个人</span><br><span class="line">3. 输入链接，接受</span><br></pre></td></tr></table></figure><h2 id="不邀请进入团队"><a href="#不邀请进入团队" class="headerlink" title="不邀请进入团队"></a>不邀请进入团队</h2><ol><li>fork一份仓库，此时仓库属于自己</li><li>git clone到本地库</li><li>修改</li><li>git push到远程库</li><li>发送pull request请求</li><li>审核</li><li>git merge</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
