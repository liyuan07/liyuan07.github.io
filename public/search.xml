<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>路过人间的情书</title>
      <link href="/2021/11/26/%E8%B7%AF%E8%BF%87%E4%BA%BA%E9%97%B4%E7%9A%84%E6%83%85%E4%B9%A6/"/>
      <url>/2021/11/26/%E8%B7%AF%E8%BF%87%E4%BA%BA%E9%97%B4%E7%9A%84%E6%83%85%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="路过人间的情书"><a href="#路过人间的情书" class="headerlink" title="路过人间的情书"></a>路过人间的情书</h1><p>如果光凭借语言无法表达给你</p><p>那我就为你写上一万封信</p><p>第一写 指尖触碰指尖 是一瞬 如一生的时间</p><p>第二写 耳朵如何听见 兵荒马乱的心上弦</p><p>第三写 眼睛荒无人烟 直到你坠入我的人间</p><p>……</p><p>第四写 银河灿烂无边 是尘埃 也要想你倾斜</p><p>第五写 肺腑滚烫如血 不足以形容的热烈</p><p>第六写 宇宙如果毁灭 生命也 只在刹那终结</p><p>……</p><p>第七写 萤火虫的夏天</p><p>第八写 一朵玫瑰胆怯</p><p>第九写 无规则的光线 落在了你名字上面</p>]]></content>
      
      
      
        <tags>
            
            <tag> 77 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法：#Leecode121买卖股票的最佳时机</title>
      <link href="/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法-Leecode406根据身高重建队列</title>
      <link href="/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-Leecode406%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
      <url>/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-Leecode406%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法：-Leecode406根据身高重建队列"><a href="#贪心算法：-Leecode406根据身高重建队列" class="headerlink" title="贪心算法：#Leecode406根据身高重建队列"></a>贪心算法：#Leecode406根据身高重建队列</h1><h2 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h2><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p><strong>一般像这种数对，还设计排序的，一般根据第一个元素正向排序，第二个元素逆向排序；或者根据第一个元素逆向排序，第二个元素正向排序</strong></p><p>就本题而言：</p><p><strong>矮个子往高个子里面插，不会改变高个子的ki。但是高个子往矮个子里面插，就会改变矮个子！</strong></p><p>所以我们先按照身高降序排列，再按照Ki升序排列。这样，当我们向ans容器里面插入数据的时候，就可以依次从头遍历people容器，把每个元素的ki当做每次循环过程中向容器里插入数据的索引值（肯定是高个子先进入，然后插入一个矮个子，根据矮个子的ki插入到ans容器里。此时无论矮个子插入到高个子的前面还是后面，都不会影响高个子的位置）</p><h2 id="解决代码"><a href="#解决代码" class="headerlink" title="解决代码"></a>解决代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>() , people.<span class="built_in">end</span>() , [](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp;u , <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp;v)&#123;<span class="comment">//u和v前面加一个&amp;符号，直接内存减半，速度翻倍……为啥子哩</span></span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">0</span>] == v[<span class="number">0</span>] ? u[<span class="number">1</span>] &lt; v[<span class="number">1</span>] : u[<span class="number">0</span>] &gt; v[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = people.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt; a : people)&#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>()+a[<span class="number">1</span>],a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="算法改进：线段树"><a href="#算法改进：线段树" class="headerlink" title="算法改进：线段树"></a>算法改进：线段树</h2><p><em>Leecode执行时间最短的代码</em></p><p><code>树相关的数据结构后期再补</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">执行用时为 <span class="number">16</span> ms 的范例</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">2048</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">int</span> n=people.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">ans</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),[&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp;x,vector&lt;<span class="keyword">int</span>&gt;&amp;y)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> x[<span class="number">0</span>]&lt;y[<span class="number">0</span>]||(x[<span class="number">0</span>]==y[<span class="number">0</span>]&amp;&amp;x[<span class="number">1</span>]&gt;y[<span class="number">1</span>]);&#125;);</span><br><span class="line">        <span class="keyword">int</span> i,j,k,l;</span><br><span class="line">        <span class="comment">//对线段树进行初始化，a[i]表示以i为根的树中空座位数量</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>,k=X,l=<span class="number">1</span>;i&lt;=X*<span class="number">2</span>;i&lt;&lt;=<span class="number">1</span>,k&gt;&gt;=<span class="number">1</span>)<span class="keyword">for</span>(j=i/<span class="number">2</span>;j--;)a[l++]=k;</span><br><span class="line">        <span class="comment">//逐个找座位</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>,k=people[i][<span class="number">1</span>];j&lt;X;--a[j])&#123;</span><br><span class="line">                j&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=a[j])k-=a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[j-X]=people[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础-项目需求向</title>
      <link href="/2021/11/25/linux%E5%9F%BA%E7%A1%80-%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%90%91/"/>
      <url>/2021/11/25/linux%E5%9F%BA%E7%A1%80-%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="linux基础（项目需求向）"><a href="#linux基础（项目需求向）" class="headerlink" title="linux基础（项目需求向）"></a>linux基础（项目需求向）</h1><h2 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong><code>删除文件</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch ./test.txt;</span><br><span class="line">rm ./test.txt;</span><br><span class="line">rm -f ./test.txt;//不询问</span><br></pre></td></tr></table></figure><p><strong><code>删除目录</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r aaa;//递归删除当前目录下的aaa目录</span><br><span class="line">rm -rf aaa;;//递归删除当前目录下的aaa目录（不询问）</span><br></pre></td></tr></table></figure><p><strong><code>全部删除</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf *将当前目录下的所有目录全部删除</span><br></pre></td></tr></table></figure><h3 id="重命名-amp-amp-剪切"><a href="#重命名-amp-amp-剪切" class="headerlink" title="重命名&amp;&amp;剪切"></a>重命名&amp;&amp;剪切</h3><p><strong><code>重命名</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 当前目录 新目录</span><br></pre></td></tr></table></figure><p><strong><code>剪切</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /user/tmp/aaa /user;</span><br></pre></td></tr></table></figure><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -r /user/temp/aaa /user#递归复制整个文件夹</span><br><span class="line">\cp -r user/tmp/aaa /user           #如果目标目录下有相同文件，会直接强制覆盖</span><br><span class="line">cp /home/aaa.txt /home/bbb #把aaa.txt文件复制到bbb文件夹里</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name &quot;hello*&quot;;</span><br></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat helloworld.cpp</span><br><span class="line">cat -n /etc/profile | more              #显示行号、管道符、分页浏览</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">more /etc/profile</span><br><span class="line">    spcae：向下翻页</span><br><span class="line">    enter: 向下翻一行</span><br><span class="line">    q    ： lika</span><br><span class="line">    ctrl+F:向下滚动一屏</span><br><span class="line">    ctrl+B:返回上一屏</span><br><span class="line">    =     ： 显示当前行的行号</span><br><span class="line">    :f    : 输出文件名和当前行的行号</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less 射雕英雄传.txt                     #分屏查看，处理打啊性文件的时候有更高的效率</span><br><span class="line">快捷键：借步度娘</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head -n 5 /etc/profile                #显示前五行</span><br><span class="line">tail -n 5 /etc/profile                #显示后五行</span><br><span class="line">tail -f /etc/profile                  #实时追踪文档的所有更新</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br><span class="line">-n 输出之后不换行</span><br><span class="line">-e 表示对转义字符按照对应的方式进行处理</span><br><span class="line"></span><br><span class="line">echo &quot;hello world &quot; &gt; test.txt #echo重定向</span><br></pre></td></tr></table></figure><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt; a.txt #&gt;输出重定向：会把原来的文件内容覆盖</span><br><span class="line"> #&gt;&gt;不会覆盖原来文件里的内容，在末尾追加</span><br><span class="line">ls -l /home/ &gt; /home/info.txt</span><br></pre></td></tr></table></figure><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root linkToRoot               #给/root建立一个快捷方式</span><br><span class="line">rm -rf linkToRoot                    #hhh</span><br></pre></td></tr></table></figure><h3 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history</span><br><span class="line">!178                                  #执行历史命令中编号为178号的指令</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /home -name helloworld.txt      #根据名称查找该文件</span><br><span class="line">fine / -name *.txt</span><br><span class="line">-user                    #查询属于指定用户的所有文</span><br><span class="line">fine /home -size +20M                    #按照大小查询文件</span><br></pre></td></tr></table></figure><h3 id="过滤和管道符号"><a href="#过滤和管道符号" class="headerlink" title="过滤和管道符号"></a>过滤和管道符号</h3><p><code>grep</code> ：过滤查找</p><p><code>|</code>:管道符，表示将抢一个命令的处理结果输出传递到给后面的命令处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n 显示匹配行及行号</span><br><span class="line">-i 忽略字母大小写</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | grep -n yes</span><br></pre></td></tr></table></figure><h2 id="用户、用户组管理及其权限管理"><a href="#用户、用户组管理及其权限管理" class="headerlink" title="用户、用户组管理及其权限管理"></a>用户、用户组管理及其权限管理</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p><strong><code>添加用户</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd xiaoming                     #创建用户成功后，会自动的创建和用户同名的家目录 </span><br><span class="line">useradd -d /home/dog xiaoming        #给新创建的用户创建家目录</span><br></pre></td></tr></table></figure><p><strong><code>给用户分配密码</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd xiaoming </span><br></pre></td></tr></table></figure><p><strong><code>删除用户</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel xiaoming                    #删除用户，但是保留家目录</span><br><span class="line">userdel -r xiaoming                 #删除用户并且删除家目录</span><br></pre></td></tr></table></figure><p><strong><code>查询用户信息</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id root</span><br><span class="line">&gt;&gt;uid=0(root)                        #用户id号</span><br><span class="line">&gt;&gt;gid=0(root)       #所在组的id号</span><br><span class="line">&gt;&gt;组=0(root) #组名</span><br></pre></td></tr></table></figure><p><strong><code>切换用户</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">su xiaoming</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong><code>查看文件的所有者</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ahl</span><br></pre></td></tr></table></figure><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd groupname</span><br><span class="line">groupdel groupname</span><br><span class="line">useradd -g groupname username#创建用户的时候增加组</span><br><span class="line">usermod -g groupname username#修改组</span><br></pre></td></tr></table></figure><h3 id="文件的所有者和所在组"><a href="#文件的所有者和所在组" class="headerlink" title="文件的所有者和所在组"></a>文件的所有者和所在组</h3><p><strong><code>修改文件的所有者</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown tom apple.txt</span><br></pre></td></tr></table></figure><p><strong><code>修改文件所在的组</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#当用户创建了一个文件之后，默认这个文件的所在组就是该用户所在的组</span><br><span class="line">chgrp 组名 文件名</span><br></pre></td></tr></table></figure><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Is -l中显示的内容如下：</span><br><span class="line">-rwxrw-r— 1 root root 1213 Feb 2 09:39 abc</span><br><span class="line">0-9位说明</span><br><span class="line">1）第0位确定文件类型（d,-,第c, b）</span><br><span class="line">2）第1-3位确定所有者（该文件的所有者）拥有该文件的权限。一User</span><br><span class="line">3）第4-6位确定所属组（同用户组的）拥有该文件的权限，一Group</span><br><span class="line">4）第7-9位确定其他用户拥有该文件的权限一Other</span><br></pre></td></tr></table></figure><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>**<code>第一种方式：+ 、 - 、 =变更权限</code> **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u:所有者g:所在组o:其他人a:所有人</span><br><span class="line">chmod u=rwx,g=rx,o=x 文件目录名</span><br><span class="line">chmod o+w 文件目录名</span><br><span class="line">chmod a-x 文件目录名</span><br></pre></td></tr></table></figure><p><strong><code>通过数字权限变更</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 751 文件目录名</span><br></pre></td></tr></table></figure><h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] newowner  file   #改变文件的所有者(如果是目录，则可以用-R对其所有的子文件递归生效)</span><br></pre></td></tr></table></figure><h3 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] newgroup file</span><br></pre></td></tr></table></figure><h2 id="压缩和解压缩（以下手头的项目暂时用不到。用到的时候我再更新）"><a href="#压缩和解压缩（以下手头的项目暂时用不到。用到的时候我再更新）" class="headerlink" title="压缩和解压缩（以下手头的项目暂时用不到。用到的时候我再更新）"></a>压缩和解压缩（以下手头的项目暂时用不到。用到的时候我再更新）</h2><h3 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h3><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><h2 id="指令运行级别"><a href="#指令运行级别" class="headerlink" title="指令运行级别"></a>指令运行级别</h2><p><strong><code>找回root密码</code></strong></p><h2 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h2><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h2 id="RPM和YUM"><a href="#RPM和YUM" class="headerlink" title="RPM和YUM"></a>RPM和YUM</h2>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法：#Leecode435无重叠区间</title>
      <link href="/2021/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode435%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
      <url>/2021/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode435%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法：-Leecode435无重叠区间"><a href="#贪心算法：-Leecode435无重叠区间" class="headerlink" title="贪心算法：#Leecode435无重叠区间"></a>贪心算法：#Leecode435无重叠区间</h1><h2 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><h2 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h2><p>先计算最多能组成多少不重叠的区间，然后用总区间个数减去不重叠区间的个数。</p><p>每次都要选择一个区间结尾最小的，这样留给后面的空间就越大，那么后面能够选的区间的个数就越多。</p><p>由于每个区间都是start&lt;end的，所以利用lamda表达式把所有的区间按照尾排序。</p><p>lamda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>() , intervals.<span class="built_in">end</span>() , [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;u , <span class="keyword">const</span> <span class="keyword">auto</span> &amp;v)&#123;<span class="comment">//如果把auto改成&lt;vector&gt;int类型会快很多</span></span><br><span class="line"><span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; u, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> edge = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= edge)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                edge = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="贪心算法：-Leecode452扎气球"><a href="#贪心算法：-Leecode452扎气球" class="headerlink" title="贪心算法：#Leecode452扎气球"></a>贪心算法：#Leecode452扎气球</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p> 示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>() , points.<span class="built_in">end</span>() , [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp;u , <span class="keyword">const</span> <span class="keyword">auto</span>&amp;v)&#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endrange = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(endrange &gt;= points[i][<span class="number">0</span>])&#123;       <span class="comment">//如果气球有重叠，那么不用管，一根箭就可以戳爆了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            endrange = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针#LeeCode680验证回文字符串Ⅱ</title>
      <link href="/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode680%E9%AA%8C%E8%AF%81%E4%BC%9A%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1/"/>
      <url>/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode680%E9%AA%8C%E8%AF%81%E4%BC%9A%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针-：-LeeCode680验证回文字符串Ⅱ"><a href="#双指针-：-LeeCode680验证回文字符串Ⅱ" class="headerlink" title="双指针 ： #LeeCode680验证回文字符串Ⅱ"></a>双指针 ： #LeeCode680验证回文字符串Ⅱ</h1><h2 id="题目重述："><a href="#题目重述：" class="headerlink" title="题目重述："></a>题目重述：</h2><p>给定一个非空字符串s，最多删除一个字符，判断是否能够成为回文字符串</p><p>实例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abca&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure><p>实例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>自己的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//这里显得多少有带你幼稚了。而且错误出现在这里</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>] == s[j] )&#123;</span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == s[j<span class="number">-1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思考：不用总是使用count等辅助变量。试试其他的思路！</p><p>关键：只允许失误一次</p><p>题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">length</span>()<span class="number">-1</span> ; i &lt;= j ; i++  ,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])&#123;<span class="comment">//唯一一次的失误机会</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isPalindrome</span>(s , i+<span class="number">1</span> , j) || <span class="built_in">isPalindrome</span>(s , i , j<span class="number">-1</span>);<span class="comment">//判断跳过左右两个字符是否会成为回文</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s , <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i++] != s[j--])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针#LeeCode524通过删除字母匹配到字典里最长单词</title>
      <link href="/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode524%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"/>
      <url>/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode524%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针：-LeeCode524通过删除字母匹配到字典里最长单词"><a href="#双指针：-LeeCode524通过删除字母匹配到字典里最长单词" class="headerlink" title="双指针：#LeeCode524通过删除字母匹配到字典里最长单词"></a>双指针：#LeeCode524通过删除字母匹配到字典里最长单词</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。</p><p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abpcplea&quot;, dictionary = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abpcplea&quot;, dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>自己的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;string&gt; save;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;<span class="comment">//1</span></span><br><span class="line">             <span class="keyword">int</span> pointer1 = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> pointer2 = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">while</span>(pointer1 != n)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(s[pointer1++] == dictionary[i][pointer2])&#123;</span><br><span class="line">                     pointer2++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(pointer2 == dictionary[i].<span class="built_in">length</span>())&#123;</span><br><span class="line">                save.<span class="built_in">push_back</span>(dictionary[i]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(save.<span class="built_in">begin</span>() == save.<span class="built_in">end</span>())&#123;<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">            string temp = save[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;save.<span class="built_in">size</span>();i++)&#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">if</span>(save[i] &lt; save[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    temp = save[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>1、2两处使用了两次循环。但是，这是两个完全相统的循环。所以是否可以只使用一次循环就完成？</p><p>3处的判断过于冗余</p><p>题解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String t : dictionary)&#123;</span><br><span class="line">            <span class="keyword">int</span> pointer1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> pointer2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pointer1 &lt; s.length() &amp;&amp; pointer2 &lt; t.length())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(pointer1++) == t.charAt(pointer2))&#123;</span><br><span class="line">                    pointer2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pointer2 == t.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.length() &gt; res.length() || ( t.length() == res.length() &amp;&amp; t.compareTo(res) &lt; <span class="number">0</span>))&#123;</span><br><span class="line">                    res = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快慢双指针#LeeCode141环形链表</title>
      <link href="/2021/11/24/%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/24/%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="快慢双指针：-LeeCode141环形链表"><a href="#快慢双指针：-LeeCode141环形链表" class="headerlink" title="快慢双指针：#LeeCode141环形链表"></a>快慢双指针：#LeeCode141环形链表</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>示例1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><h2 id="题解：Floyd判圈法"><a href="#题解：Floyd判圈法" class="headerlink" title="题解：Floyd判圈法"></a>题解：Floyd判圈法</h2><p>算法思想：假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;<span class="comment">//判断条件是两个何时相等</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)&#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;<span class="comment">//每次走一格</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;<span class="comment">//每次走两格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1：巧用或运算。先判断前件，如果前件不满足，则直接不考虑后件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2021/11/24/Git/"/>
      <url>/2021/11/24/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="工作区，暂存区，本地库"><a href="#工作区，暂存区，本地库" class="headerlink" title="工作区，暂存区，本地库"></a>工作区，暂存区，本地库</h1><h2 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init//在某个文件夹内执行该指令，该文件夹就会成为本地的workspace</span><br></pre></td></tr></table></figure><p>git init生成.git文件，是隐藏文件，如果需要访问需要<code>ls -lA</code>。</p><p>.git目录中存放的是本地库相关的子目录和文件，不要乱动</p><h3 id="设置签名-：-区分不同开发人员的身份（和登录远程库的账号密码无关）"><a href="#设置签名-：-区分不同开发人员的身份（和登录远程库的账号密码无关）" class="headerlink" title="设置签名 ： 区分不同开发人员的身份（和登录远程库的账号密码无关）"></a>设置签名 ： 区分不同开发人员的身份（和登录远程库的账号密码无关）</h3><p>项目级别/仓库级别：仅在当前工作区有效</p><p>系统用户级别：当前操作系统的用户范围</p><p>项目级别优先于系统用户级别，如果没有项目级别就是用系统用户级别的签名</p><p>查看签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config -l             //所有的配置 = system+global</span><br><span class="line">git config --system --list    //系统配置</span><br><span class="line">git config --global --list    //全局配置，用户自己的配置</span><br></pre></td></tr></table></figure><p>配置签名： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;liyuan&quot;</span><br><span class="line">git config user.email &quot;liyuan_sunny@163.com&quot;//保存在./.git/config文件中</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;liyuan&quot;</span><br><span class="line">git config --gloabl user.email &quot;liyuan_sunny@163.com&quot;   //保存在~/.gitconfig</span><br></pre></td></tr></table></figure><h3 id="配置ssh免密登录"><a href="#配置ssh免密登录" class="headerlink" title="配置ssh免密登录"></a>配置ssh免密登录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">rm -rf .ssh</span><br><span class="line">ssh-keygen -t rsa -C liyuan_sunny@163.com</span><br><span class="line">cd .ssh</span><br><span class="line">cat id_isa.pub</span><br><span class="line">复制公钥，到github</span><br><span class="line">git remote add origin_ssh git@…………</span><br><span class="line">git push origin_ssh helloworld.cpp</span><br></pre></td></tr></table></figure><h3 id="SSL验证错误"><a href="#SSL验证错误" class="headerlink" title="SSL验证错误"></a>SSL验证错误</h3><p>在提交的时候遇到了报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/LYinGithub/hello-world.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>解决方法：但是每次push都需要这么一串代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status //查看当前工作区、暂存区的状态</span><br><span class="line">vim helloworld.txt  //创建一个未追踪的文件</span><br><span class="line">git add &lt;文件名&gt;   //只能用git add将本地未追踪的文件添加到暂存区</span><br><span class="line">git rm --cached &lt;文件名&gt;    //将暂存区的取回</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>快照流。提交没有变的部分是提供一个指向上一个对象的指针，存储差异。考虑到git的轻量级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit &lt;文件名&gt;          //暂存区的修改提交到本地库。</span><br><span class="line">git commit -m &quot;注释&quot; &lt;文件名&gt; //当场写注释</span><br></pre></td></tr></table></figure><p>如果修改该文件已追踪的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//第一次提交</span><br><span class="line">vim helloworld.txt;</span><br><span class="line">git add helloworld.txt;</span><br><span class="line">git commit -m &quot;the first test&quot; helloworld.txt</span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">vim helloworld.txt</span><br><span class="line"></span><br><span class="line">//第二次提交</span><br><span class="line">git add + git commit -m //由于已经追踪过该文件，所以可以用git add添加到暂存区，也可以直接commit</span><br><span class="line">git commit -a</span><br><span class="line">(git reset HEAD helloworld.txt)//可以使用这个命令从暂存区取回</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="git-log-：-查看当前本地库的提交记录"><a href="#git-log-：-查看当前本地库的提交记录" class="headerlink" title="git log ： 查看当前本地库的提交记录"></a>git log ： 查看当前本地库的提交记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log                    //空格向下翻页，b向上翻页，q退出</span><br><span class="line">git log --pretty=oneline   //每个日志只显示一行</span><br><span class="line">git log --oneline</span><br><span class="line">git reflog                 //查看回退到各个版本HEAD指针需要走几步</span><br></pre></td></tr></table></figure><h3 id="git-reset-git-revert撤销变更"><a href="#git-reset-git-revert撤销变更" class="headerlink" title="git reset/git revert撤销变更"></a>git reset/git revert撤销变更</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard hashindex//前进后退都行       HEAD^^//本地</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD~100//回滚100个版本（~num &amp;&amp; ^ 的相对引用）</span><br><span class="line">git reset --hart HEAD^^  //回滚2个版本</span><br><span class="line"></span><br><span class="line">git revert //云端</span><br></pre></td></tr></table></figure><p>–soft参数 ： 仅仅是在本地库移动HEAD指针（会显得缓存区的文件出现了修改。其实实际上没有改，是因为本地库回滚，看样子暂存区修改了）</p><p>–mixed参数：在本地库移动HEAD指针，并且重置暂存区（会显得工作区的文件出现了修改）</p><p>–hard参数：移动本地库的HEAD指针，重置暂存区，重置工作区</p><h3 id="rm-lt-filename-gt"><a href="#rm-lt-filename-gt" class="headerlink" title="rm &lt;filename&gt;"></a>rm &lt;filename&gt;</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;filename&gt; //删除这个文件，通常指的是提交到本地库之后删除这个文件</span><br><span class="line">rm helloworld.txt</span><br><span class="line">ll              //发现工作区已经没有这个文件了</span><br><span class="line">git add helloworld.txt    //把删除helloworld.txt的这条指令添加到暂存区</span><br><span class="line">git commit -m &quot;hhh&quot; helloworld.txt;</span><br><span class="line">git status               //发现工作区和缓存区清空</span><br><span class="line">git reset HEAD^              //可以通过上一个版本找回这个文件</span><br></pre></td></tr></table></figure><p>如果已经把删除的指令提交到暂存区，但是还没提交到本地库。怎么取回这条操作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD;</span><br></pre></td></tr></table></figure><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld.txt             </span><br><span class="line">git diff                    //无其他参数：和暂存区比较</span><br><span class="line">git diff HEAD helloworld.txt   //和本地库比较</span><br><span class="line">git diff HEAD^^                //和本地库的前几个版本比较</span><br></pre></td></tr></table></figure><h3 id="git-tag-git-describe………………（用到再说）"><a href="#git-tag-git-describe………………（用到再说）" class="headerlink" title="git tag / git describe………………（用到再说）"></a>git tag / git describe………………（用到再说）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1 C1//为C1创建一个名叫V1的标签</span><br><span class="line">git describe//返回距离最近标签之间的版本差距信息</span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v               //查看所有分支名</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch bugFix//创建一个名叫bugFix的分支，内容是从master分支复制而来</span><br><span class="line">git branch -b bugFix C1//在C1处创建一个名叫bugFix的分支并且使指针指向他</span><br><span class="line">git branch -f main HEAD//强制将main指针移动到HEAD指针所在的位置，这个不一定是指针，也可以是任意一个提交版本的位置，这个命令就是操控分支指针的命令</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout bugFix//当前在bugFix分支</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>git merge能有有效的保护历史</p><ol><li>切换到接受修改的分支（被合并，增加新内容）</li><li>执行merge命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge bugFix//目前指针在m。main吸收main和bugFix两个分支，之后指针仍然指向main</span><br></pre></td></tr></table></figure><h4 id="git-merge-git-rebase-git-cherry-pick（未实战）"><a href="#git-merge-git-rebase-git-cherry-pick（未实战）" class="headerlink" title="git merge/git rebase/git cherry-pick（未实战）"></a>git merge/git rebase/git cherry-pick（未实战）</h4><p>git rebase能够让整个项目看起来极其线性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git rebase main//目前指针在bugFix，将bugFix复制到main的新的提交，之后指针仍然指向bugFix </span><br><span class="line">//bugFix原来的分支仍然存在</span><br><span class="line"></span><br><span class="line">git rebase bugFix//因为此时bugFix指向main，所以git知识简单的把main分支的引用向前移动了一下</span><br><span class="line"></span><br><span class="line">git rebase -i HEAD~4//出现UI窗口，你可以决定如何复制</span><br><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>git cherry-pick实现自由复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick C1 C2 C3;</span><br></pre></td></tr></table></figure><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p> 冲突内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaaaa</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD   /*</span><br><span class="line">hhhhhhhhhhhh当前分支得到内容</span><br><span class="line">=============     *//*另一分支的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;master*/</span><br><span class="line">iiiiiiiiiiiii</span><br><span class="line">jjjjjjjjjjjj</span><br></pre></td></tr></table></figure><p>解决冲突 ： 删除掉字符就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld.txt          //删除掉不需要的东西</span><br><span class="line">git add helloworld.txt                  //使用git add标志文件为已解决。此时所有冲突都被解决，但是仍然没有合并</span><br><span class="line">git commit -m &quot;ok merge&quot;                //不带文件名</span><br></pre></td></tr></table></figure><h1 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h1><h2 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote -v       //查看本地现有的地址别名</span><br><span class="line">git remote add origin https://github.com/LYinGithub/hello-world.git  //给这串地址取别名为origin</span><br></pre></td></tr></table></figure><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><ol><li>完整的把远程库下载到本地</li><li>创建origin远程地址别名</li><li>初始化本地库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LYinGithub/hello-world.git</span><br></pre></td></tr></table></figure><h3 id="git-Push"><a href="#git-Push" class="headerlink" title="git Push"></a>git Push</h3><p>将当前分支推送到云端仓库。</p><p>远程仓库接收到了更新，远程仓库的main指向新的更新，同时我们的远程分支<code>origin/main</code>也同时更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git Push</span><br></pre></td></tr></table></figure><h4 id="git-push的参数-1-：-git-push-lt-remote-gt-lt-place-gt"><a href="#git-push的参数-1-：-git-push-lt-remote-gt-lt-place-gt" class="headerlink" title="git push的参数 1 ： git push  &lt;remote&gt; &lt;place&gt;"></a>git push的参数 1 ： git push  &lt;remote&gt; &lt;place&gt;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main(指定place参数,即要推送的分支)</span><br></pre></td></tr></table></figure><p>翻译过来就是：<strong>切换到本地仓库的“main”</strong>，获取所有的提交，再到远程仓库”orirgin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去</p><p>如果不指定参数会发生什么?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout C0</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>什么也不会发生，因为我们所检出的HEAD没有跟踪任何分支</p><h4 id="git-push的参数2：git-push-origin-lt-source-gt-lt-destination-gt"><a href="#git-push的参数2：git-push-origin-lt-source-gt-lt-destination-gt" class="headerlink" title="git push的参数2：git push origin &lt;source&gt; &lt;destination&gt;"></a>git push的参数2：git push origin &lt;source&gt; &lt;destination&gt;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin f00^:main//把本地库的foo的父提交推送到远端仓库的main分支中</span><br></pre></td></tr></table></figure><p>如果要推送的分支不存在会怎么样？git会在你远程仓库中根据提供的名称创建这个分支</p><p>同时本地也会在提交的节点创建origin/newBranch远程分支追踪远程仓库中的newBranch分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main:newBranch</span><br></pre></td></tr></table></figure><h4 id="git-push的参数3：奇怪的-lt-source-gt"><a href="#git-push的参数3：奇怪的-lt-source-gt" class="headerlink" title="git push的参数3：奇怪的&lt;source&gt;"></a>git push的参数3：奇怪的&lt;source&gt;</h4><p>通过push传控制source，可以删除远程仓库中的side分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :side</span><br></pre></td></tr></table></figure><h4 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h4><p>必须基于远程库的最新分支才能够push，否则会被git决绝请求—-&gt;使用rebase调整本地库的工作</p><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase origin/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>需要更新本地仓库的远程分支，然后用rebase将我们的工作移动到最新的提交记录，然后再用git push推送到远程仓库</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>将远程仓库的更新下载到本地，但是不修改本地文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch//把远程仓库的更新下载到本地，同时远程分支origin/main也被更新，然而原本的main不会改变</span><br></pre></td></tr></table></figure><h4 id="git-fetch的参数1：与git-push十分相似，知识方向相反罢了"><a href="#git-fetch的参数1：与git-push十分相似，知识方向相反罢了" class="headerlink" title="git fetch的参数1：与git push十分相似，知识方向相反罢了"></a>git fetch的参数1：与git push十分相似，知识方向相反罢了</h4><p>在远程仓库的<code>foo</code>分支上，获取所有本地不存在的提交，放到本地的origin/foo上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br><span class="line">git checkout origin/foo</span><br><span class="line">cat helloworld.txt         //可以看到本地库里helloworld的变化了</span><br></pre></td></tr></table></figure><p>问：为什么不是将git放到本地的<code>foo</code>分支（及抓取后将文件放在本地库，但是没有修改工作区的文件）</p><p>答：因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 <code>git fetch</code> 课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）</p><h4 id="git-fetch的参数2："><a href="#git-fetch的参数2：" class="headerlink" title="git fetch的参数2："></a>git fetch的参数2：</h4><p>git将<code>foo~1</code>解析成一个origin的仓库位置，然后将那些提交记录下载到本地的bar（存在）分支，注意由于制定了目标分支，我们其他的分支都没有被更新</p><p>注：如果本地的bar分支不存在怎么办？git会创建一个bar分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo~1:bar</span><br></pre></td></tr></table></figure><h4 id="git-fetch没有参数："><a href="#git-fetch没有参数：" class="headerlink" title="git fetch没有参数："></a>git fetch没有参数：</h4><p>如果<code>git fetch</code>没有参数，它会下载所有的提交记录到各个远程分支</p><h4 id="git-fetch参数4：奇怪的-lt-source-gt"><a href="#git-fetch参数4：奇怪的-lt-source-gt" class="headerlink" title="git fetch参数4：奇怪的&lt;source&gt;"></a>git fetch参数4：奇怪的&lt;source&gt;</h4><p>fetch一个空source到本地，会在本地创建一个新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin :bugFix</span><br></pre></td></tr></table></figure><h3 id="git-Pull-git-fetch-git-merge"><a href="#git-Pull-git-fetch-git-merge" class="headerlink" title="git Pull = git fetch + git merge"></a>git Pull = git fetch + git merge</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull = git fetch + git merge origin/main</span><br></pre></td></tr></table></figure><p>注意：git pull必须基于本地remote tracking branch</p><p>否则git pull –rebase会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">side3 is not a remote tracking branch!I don&#x27;t know where to pull</span><br></pre></td></tr></table></figure><h4 id="git-pull的参数"><a href="#git-pull的参数" class="headerlink" title="git pull的参数"></a>git pull的参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin foo = git fetch origin foo</span><br><span class="line">git merge origin/foo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin bar~1:bugFix = git feetch origin bar~1:bugFix</span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure><h2 id="远程追踪分支：origin-main与remote-tracking"><a href="#远程追踪分支：origin-main与remote-tracking" class="headerlink" title="远程追踪分支：origin/main与remote tracking"></a>远程追踪分支：origin/main与remote tracking</h2><h3 id="关于origin-main"><a href="#关于origin-main" class="headerlink" title="关于origin/main"></a>关于origin/main</h3><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout origin/main</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>HEAD会直接变成分离状态。而origin/main不会更新。</p><p>由于remote tracking机制的存在，main背设定为追踪origin/main，这意味着main分支制定了推送的目的地以及拉去后合并的目标</p><h3 id="自定义追踪origin-main-：-git-checkout-b-branchname-origin-main"><a href="#自定义追踪origin-main-：-git-checkout-b-branchname-origin-main" class="headerlink" title="自定义追踪origin/main ： git checkout -b branchname origin/main"></a>自定义追踪origin/main ： git checkout -b branchname origin/main</h3><p>可以自定义任意分支追踪origin/main，然后分支就会像main分支一样隐含的push目的地以及merge的目标。</p><p>//创建一个名为totalNotMain分支，然后追踪远程分支origin/main ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b tootalNotMain origin/main</span><br></pre></td></tr></table></figure><p>//pull : 使用foo来追踪origin/main，在pull之后，foo会跟随origin/main更新，然而main没有被更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo origin/main</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>//push：由于git checkout -b foo本身就是创建一个分支，然后使指针指向他。所以提交之后main不会更改，而foo会更改</p><p>//push之后origin/main会到达foo的位置，而main会停留在原地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo origin/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="自定义追踪-：-git-branch-u"><a href="#自定义追踪-：-git-branch-u" class="headerlink" title="自定义追踪 ： git branch -u"></a>自定义追踪 ： git branch -u</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/main foo</span><br></pre></td></tr></table></figure><p>如果当前节点在foo上，那么还可以省略foo ： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/main</span><br></pre></td></tr></table></figure><h1 id="git跨团队协作"><a href="#git跨团队协作" class="headerlink" title="git跨团队协作"></a>git跨团队协作</h1><h2 id="邀请加入团队"><a href="#邀请加入团队" class="headerlink" title="邀请加入团队"></a>邀请加入团队</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. repository-&gt;setting-&gt;collaborators+被邀请人的GitHub账号</span><br><span class="line">2. 复制链接，发送给那个人</span><br><span class="line">3. 输入链接，接受</span><br></pre></td></tr></table></figure><h2 id="不邀请进入团队"><a href="#不邀请进入团队" class="headerlink" title="不邀请进入团队"></a>不邀请进入团队</h2><ol><li>fork一份仓库，此时仓库属于自己</li><li>git clone到本地库</li><li>修改</li><li>git push到远程库</li><li>发送pull request请求</li><li>审核</li><li>git merge</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
