<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>父类指针（或引用）指向父类对象和子类对象时的深刻理解</title>
      <link href="/2021/11/30/%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%EF%BC%88%E6%88%96%E5%BC%95%E7%94%A8%EF%BC%89%E6%8C%87%E5%90%91%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3/"/>
      <url>/2021/11/30/%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%EF%BC%88%E6%88%96%E5%BC%95%E7%94%A8%EF%BC%89%E6%8C%87%E5%90%91%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生活不知眼前的苟且，还有诗和远方……</p></blockquote><h1 id="赋值兼容规则"><a href="#赋值兼容规则" class="headerlink" title="赋值兼容规则"></a>赋值兼容规则</h1><ul><li>父类的指针指向父类的对象时 : 访问父类的成员</li><li>父类的指针指向子类的对象时 : 访问子类从父类继承下来的那部分数据成员</li></ul><h1 id="函数隐藏"><a href="#函数隐藏" class="headerlink" title="函数隐藏"></a>函数隐藏</h1><p><em>当子类和父类拥有同名的成员变量的时候</em></p><ul><li>父类的指针指向子类对象 : 访问的是继承来的父类中的同名成员变量(成员函数)</li><li>在子类内部或者用子类的对象在子类外访问此同名成员，访问自己类中重新定义的成员</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><em>当子类中重写了父类的虚函数</em></p><ul><li>父类的指针指向父类对象 ： 调用的是父类中的虚函数</li><li>父类的指针指向子类对象 ： 调用的是子类的虚函数<ul><li>当父类的指针指向子类对象时，此时<strong>子类对象中</strong> <strong>从父类继承下的虚函数指针所指向的虚函数表</strong>中的虚函数的入口地址<strong>被子类重写</strong>，所以此时用父类的指针指向子类对象时，找到的是子类的同名虚函数地址</li></ul></li><li>同时满足赋值兼容规则（不管父类的指针指向父类对象还是子类对象，父类指针只能访问父类的内容）</li></ul><hr><h1 id="深刻理解-子类对象中的父类虚函数表指针所指向的虚函数表中虚函数的入口地址被子类重写"><a href="#深刻理解-子类对象中的父类虚函数表指针所指向的虚函数表中虚函数的入口地址被子类重写" class="headerlink" title="深刻理解 : 子类对象中的父类虚函数表指针所指向的虚函数表中虚函数的入口地址被子类重写"></a>深刻理解 : 子类对象中的父类虚函数表指针所指向的虚函数表中虚函数的入口地址被子类重写</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A constructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">         <span class="built_in">f</span>();&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;A::f()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;A::g()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;A::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">       <span class="built_in">f</span>(); <span class="built_in">g</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::f()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::g()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> main&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"><span class="comment">//test1</span></span><br><span class="line">A* p = &amp;b;<span class="comment">//父类的指针指向子类的引用.此时子类中的虚函数表中虚函数入口地址被重写</span></span><br><span class="line">p-&gt;<span class="built_in">h</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">//test2</span></span><br><span class="line">b.<span class="built_in">h</span>(); <span class="comment">//由于继承关系,子类中的虚函数表中的虚函数入口地址已经被重写.所以即使在父类中调用f(),仍然会输出重写后的函数体内容.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果:</span></span><br><span class="line"><span class="function">class A constructor</span></span><br><span class="line"><span class="function"><span class="title">A::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">class A constructor</span></span><br><span class="line"><span class="function"><span class="title">A::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">A::h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">B::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">A::g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">A::h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">B::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">A::g</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><hr><h1 id="深刻理解-重写和重载"><a href="#深刻理解-重写和重载" class="headerlink" title="深刻理解 : 重写和重载"></a>深刻理解 : 重写和重载</h1><p><strong>重载</strong> : 函数名相同 , 形参列表去除默认值后不同 , 返回值(可以)不同</p><p><strong>重写</strong> : 函数名 , 形参列表 , 返回值均相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f1 of base&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f2 of base&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f3 of base&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f4 of base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">derive</span> :</span> <span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f1 of derive&quot;</span>;&#125;<span class="comment">//重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;f2 of derive&quot;</span>;&#125;<span class="comment">//重载</span></span><br><span class="line">    <span class="comment">//int f3()&#123;cout&lt;&lt;&quot;f3 of derive&quot;&lt;&lt;endl;return 0;&#125;//都不是</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;cout&lt;&lt;<span class="string">&quot;f4 of derive&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="空虚函数"><a href="#空虚函数" class="headerlink" title="空虚函数"></a>空虚函数</h1><p>派生类并不一定必须实现基类中的虚函数。如果派生类想通过虚函数机制访问虚函数，则<strong>需要保持一条从基类到派生类的虚函数路径。</strong>许多没有使用虚函数的中间类<strong>最好也要</strong>声明一下该虚函数，以保证其后的派生类能使用该虚函数。此时，可以通过声明一个空的虚函数来达到此目的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;class base!\n&quot;</span>&lt;&lt;endl&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> :</span> <span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span> <span class="keyword">public</span> son&#123;</span><br><span class="line">   <span class="keyword">public</span> : <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;class grandson\n&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构造函数和析构函数中的虚函数-dog都不这么写"><a href="#构造函数和析构函数中的虚函数-dog都不这么写" class="headerlink" title="构造函数和析构函数中的虚函数(dog都不这么写)"></a>构造函数和析构函数中的虚函数(dog都不这么写)</h1><p>在构造函数中调用虚函数时，采用静态联编，即<strong>它所调用的虚函数是自己的类或基类中定义的函数</strong>，而不是在任何派生类中重新定义的函数.</p><p>析构函数和构造函数情况一样，即<strong>析构函数所调用的虚函数是自己类中或基类中定义的虚函数</strong>。这是因为，在对象撤销时，该对象所包含的在派生类中定义的成员先于基类子对象撤销</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;cout&lt;&lt;<span class="string">&quot;base::vf() called&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> :</span> <span class="keyword">public</span> base&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">son</span>()&#123;<span class="built_in">vf</span>();&#125;<span class="comment">//这里往上找</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="built_in">vf</span>();&#125;<span class="comment">//这里往下找</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span> <span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">grandson</span>()&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">vf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;cout&lt;&lt;<span class="string">&quot;grandson::vf() called&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    grandson gs;</span><br><span class="line">    gs.<span class="built_in">g</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果:</span></span><br><span class="line">base::<span class="built_in">vf</span>() <span class="function">called</span></span><br><span class="line"><span class="function"><span class="title">grandson::vf</span><span class="params">()</span> called</span></span><br></pre></td></tr></table></figure><p>参考文献 ：<a href="https://blog.csdn.net/gogogo_sky/article/details/73380148?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%88%B6%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-73380148.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187">CSDN gogogo_sky的博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程</title>
      <link href="/2021/11/27/Shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/11/27/Shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h1><h2 id="Shell脚本的执行方式"><a href="#Shell脚本的执行方式" class="headerlink" title="Shell脚本的执行方式"></a>Shell脚本的执行方式</h2><ul><li>脚本以<code>#!/bin/bash</code>开头</li><li>脚本需要有可执行权限 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello world!&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">脚本运行方式一</span></span><br><span class="line">chmod 744 myShell.sh#给所有者一个x权限</span><br><span class="line">.myShell.sh                 #相对路径</span><br><span class="line">/root/shell/myShell.sh #绝对路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">脚本运行方式二（不推荐）</span></span><br><span class="line">sh ./myShell.sh</span><br></pre></td></tr></table></figure><h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p><code>$ HOME </code> <code>$PWD</code> <code>$SHELL</code> <code>$USER</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;PATH=$PATH&quot;</span><br><span class="line">echo &quot;user=$USER&quot;</span><br></pre></td></tr></table></figure><h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><ul><li><p>定义变量：variable=value（<em>变量名称一般大写</em>）</p></li><li><p>撤销变量：unset variable</p></li><li><p>静态变量：readonly variable ， 注意：不能reset</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">case</span> 1</span></span><br><span class="line">A=100</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line">unset A</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">case2</span></span><br><span class="line">readonly A=99</span><br><span class="line">echo &quot;A=$A&quot;</span><br></pre></td></tr></table></figure><ul><li><p>将命令的返回值赋给变量</p><ul><li>反引号：<code>A=ls -la</code></li><li>括号：<code>A=$(ls -la)</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RESULT=`ls -la /home`</span><br><span class="line">echo $RESULT</span><br><span class="line">MY_DATE=$(date)</span><br><span class="line">echo &quot;date=$MY_DATE&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#多行注释</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">export variable=value   #(将shell变量输出位环境变量)</span><br><span class="line">source 配置文件#(让修改后的配置信息立即生效)</span><br><span class="line">echo $变量名 #(查询环境变量的值)</span><br><span class="line">!</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TOMECAT_HOME=/opt/tomcat</span><br><span class="line">export TOMCAT_HOME</span><br><span class="line"></span><br><span class="line">source /etc/profile#在输出值之前，需要让其生效</span><br><span class="line">echo $TOMCAT_HOME#查看环境变量home的值</span><br></pre></td></tr></table></figure></li></ul><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$n #n表示数字，$0表示命令本身，$1-$9代表第一到第九个参数,10以上的参数需要用大括号包含$&#123;10&#125;</span><br><span class="line">$* #代表命令行中的所有参数,$*把所有参数看成一个整体</span><br><span class="line">$@ #代表命令行中的所有参数,$@把每个参数区分对待</span><br><span class="line">$# #代表命令行中所有参数的个数</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$0 $1 $2&quot;</span><br><span class="line">echo &quot;$*&quot;</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;参数个数=$#&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;./positionPara.sh 30 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;./positionPara.sh 30 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;30 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;30 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;参数个数=2</span></span><br></pre></td></tr></table></figure><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p><code>就是shell设计者实现已经定义好的变量,可以在shell脚本中使用</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$#返回当前进程的进程号</span><br><span class="line">$!#返回后海运行的最后一个进程的进程号</span><br><span class="line">$?#最后一次执行的命令的返回状态.如果这个变量的值为0,证明上一个命令成功执行了.如果这个两名不是0(具体时间哪个值由用户自己决定),则证明上一个命令没有成功执行</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;当前的进程号=$$&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">后台的额方式运行myShell.sh</span></span><br><span class="line">./myShell.sh &amp;#通过&amp;的方式后台运行某脚本</span><br><span class="line">echo &quot;最后运行的进程号=$!&quot;</span><br><span class="line">echo &quot;执行的值=$?&quot;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#case 1</span><br><span class="line">&quot;$((运算式))&quot; 或 $[运算式]</span><br><span class="line">#case 2</span><br><span class="line">expr m + n                    #注意 , m和n之间要有空格</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">case</span> 1</span></span><br><span class="line">RESULT1=$(((2+3)*4))</span><br><span class="line">echo &quot;result=$RESULT1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">case</span> 2</span></span><br><span class="line">RESULT2=$[(2+3)*4]</span><br><span class="line">echo &quot;result=$RESULT2&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">case</span> 3</span></span><br><span class="line">TEMP=`expr 2 + 3`</span><br><span class="line">RESULT=`expr $TEMP \* 4`</span><br><span class="line">echo &quot;result=$RESULT&quot;</span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><code>[ condition ](0为true , &gt;1为false)</code></p><p><em>常见判断条件</em></p><table><thead><tr><th align="center"></th><th>两个整数的比较</th></tr></thead><tbody><tr><td align="center">=</td><td>两个字符串比较是否相等</td></tr><tr><td align="center">-lt</td><td>小于</td></tr><tr><td align="center">-le</td><td>小于等于</td></tr><tr><td align="center">-eq</td><td>等于</td></tr><tr><td align="center">-gt</td><td>大于</td></tr><tr><td align="center">-ge</td><td>大于等于</td></tr><tr><td align="center">-ne</td><td>不等于</td></tr></tbody></table><table><thead><tr><th align="center"></th><th>按照文件权限进行判断</th></tr></thead><tbody><tr><td align="center">-r</td><td>判断文件是否有读的权限</td></tr><tr><td align="center">-w</td><td>判断文件是否有写的权限</td></tr><tr><td align="center">-x</td><td>判断文件是否有执行的权限</td></tr></tbody></table><table><thead><tr><th align="center"></th><th>按照文件类型进行判断</th></tr></thead><tbody><tr><td align="center">-f</td><td>文件存在并且是一个常规的文件</td></tr><tr><td align="center">-e</td><td>文件存在</td></tr><tr><td align="center">-d</td><td>文件存在并且是一个目录</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ -e /root/shell/aaa.txt ]</span><br><span class="line">then</span><br><span class="line">echo &quot;文件存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;及格了&quot;</span><br><span class="line">elif [ condition ]</span><br><span class="line">then</span><br><span class="line">echo &quot;没及格&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">&quot;q1&quot;)</span><br><span class="line">echo &quot;一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;q2&quot;)</span><br><span class="line">echo &quot;二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;other&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">echo &quot;the sum is $i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUM=0</span><br><span class="line">for((i=1;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">done</span><br><span class="line">echo &quot;sum=$SUM&quot;</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [$i -le $1]</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;sum=$SUM&quot;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read [](参数)</span><br><span class="line">-p : 指定读取值时的指示符</span><br><span class="line">-t : 指定读取值时等待的时间(秒).如果超过这个时间还没有读入,就停止等待</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/bash</span></span><br><span class="line">read -p 10 &quot;请输入一个数字num1=&quot; NUM1</span><br><span class="line">echo &quot;你输入的值时num1=$NUM1&quot;</span><br></pre></td></tr></table></figure><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><ul><li><p><strong>basename</strong> : 返回完整路径的最后 / 的部分,常用于获取文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">basename [pathname] [suffix]</span><br><span class="line">basenaem [string]   [suffix]</span><br><span class="line">(如果suffix被指定了,则basename命令会删除掉pathname或者string中的suffix)</span><br></pre></td></tr></table></figure></li><li><p><strong>dirname</strong> : 返回完整路径最后 / 的前面的部分,常用语返回路径部分</p></li></ul><p>​    <em>Excample</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">basename /home/aaa/test.txt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;test.txt</span></span><br><span class="line">basename /home/aaa/test.txt .txt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;<span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">dirname /home/aaa/test.txt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;/home/aaa</span></span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><em>Excample</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function getSum()&#123;#括号里无形参</span><br><span class="line">SUM=$[$n1+$n2]</span><br><span class="line">echo &quot;SUM=$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;请输入第一个数n1=&quot; n1</span><br><span class="line">rear -p &quot;请输入第二个数n2=&quot; n2</span><br><span class="line"><span class="meta">#</span><span class="bash">调用getSum</span></span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure><h1 id="Shell编程综合案例"><a href="#Shell编程综合案例" class="headerlink" title="Shell编程综合案例"></a>Shell编程综合案例</h1>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路过人间的情书</title>
      <link href="/2021/11/26/%E8%B7%AF%E8%BF%87%E4%BA%BA%E9%97%B4%E7%9A%84%E6%83%85%E4%B9%A6/"/>
      <url>/2021/11/26/%E8%B7%AF%E8%BF%87%E4%BA%BA%E9%97%B4%E7%9A%84%E6%83%85%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="路过人间的情书"><a href="#路过人间的情书" class="headerlink" title="路过人间的情书"></a>路过人间的情书</h1><p>如果光凭借语言无法表达给你</p><p>那我就为你写上一万封信</p><p>第一写 指尖触碰指尖 是一瞬 如一生的时间</p><p>第二写 耳朵如何听见 兵荒马乱的心上弦</p><p>第三写 眼睛荒无人烟 直到你坠入我的人间</p><p>……</p><p>第四写 银河灿烂无边 是尘埃 也要想你倾斜</p><p>第五写 肺腑滚烫如血 不足以形容的热烈</p><p>第六写 宇宙如果毁灭 生命也 只在刹那终结</p><p>……</p><p>第七写 萤火虫的夏天</p><p>第八写 一朵玫瑰胆怯</p><p>第九写 无规则的光线 落在了你名字上面</p>]]></content>
      
      
      
        <tags>
            
            <tag> 77 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法：#Leecode121买卖股票的最佳时机</title>
      <link href="/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法：-Leecode121买卖股票的最佳时机"><a href="#贪心算法：-Leecode121买卖股票的最佳时机" class="headerlink" title="贪心算法：#Leecode121买卖股票的最佳时机"></a>贪心算法：#Leecode121买卖股票的最佳时机</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><p>记录前面的最小价格，以当天为卖出价格。计算每天的卖出价格，如果小于最小价格，就更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minprice = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> price : prices)&#123;</span><br><span class="line">    maxprofit = <span class="built_in">max</span>(maxprofit , price - minprice);</span><br><span class="line">    minprice = <span class="built_in">min</span>(minprice , price);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="贪心算法：-Leecode122买卖股票的最佳时机2"><a href="#贪心算法：-Leecode122买卖股票的最佳时机2" class="headerlink" title="贪心算法：#Leecode122买卖股票的最佳时机2"></a>贪心算法：#Leecode122买卖股票的最佳时机2</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>引用评论区第一的大佬的一句话：</p><p>“<code>[7, 1, 5, 6]</code> 第二天买入，第四天卖出，收益最大（6-1），所以一般人可能会想，怎么判断不是第三天就卖出了呢? 这里就把问题复杂化了，根据题目的意思，当天卖出以后，当天还可以买入，所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） === 6 - 1）。所以算法可以直接简化为只要今天比昨天大，就卖出。”</p><h2 id="算法实现-：-双指针"><a href="#算法实现-：-双指针" class="headerlink" title="算法实现 ： 双指针"></a>算法实现 ： 双指针</h2><ol><li>双指针</li><li>从后往前看</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = prices.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = p1 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2 &gt;= <span class="number">0</span> &amp;&amp; prices[p2] &gt;= prices[p1])&#123;<span class="comment">//这里一定要加强逻辑限定。否则保证越界</span></span><br><span class="line">                p1 = p2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p2 &gt;= <span class="number">0</span> &amp;&amp; prices[p2] &lt;= prices[p1])&#123;<span class="comment">//！这里也一定要加强逻辑限定!</span></span><br><span class="line">                profit += prices[p1] - prices[p2];</span><br><span class="line">                p1 = p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法-Leecode406根据身高重建队列</title>
      <link href="/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-Leecode406%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
      <url>/2021/11/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-Leecode406%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法：-Leecode406根据身高重建队列"><a href="#贪心算法：-Leecode406根据身高重建队列" class="headerlink" title="贪心算法：#Leecode406根据身高重建队列"></a>贪心算法：#Leecode406根据身高重建队列</h1><h2 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h2><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p><strong>一般像这种数对，还设计排序的，一般根据第一个元素正向排序，第二个元素逆向排序；或者根据第一个元素逆向排序，第二个元素正向排序</strong></p><p>就本题而言：</p><p><strong>矮个子往高个子里面插，不会改变高个子的ki。但是高个子往矮个子里面插，就会改变矮个子！</strong></p><p>所以我们先按照身高降序排列，再按照Ki升序排列。这样，当我们向ans容器里面插入数据的时候，就可以依次从头遍历people容器，把每个元素的ki当做每次循环过程中向容器里插入数据的索引值（肯定是高个子先进入，然后插入一个矮个子，根据矮个子的ki插入到ans容器里。此时无论矮个子插入到高个子的前面还是后面，都不会影响高个子的位置）</p><h2 id="解决代码"><a href="#解决代码" class="headerlink" title="解决代码"></a>解决代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>() , people.<span class="built_in">end</span>() , [](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp;u , <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp;v)&#123;<span class="comment">//u和v前面加一个&amp;符号，直接内存减半，速度翻倍……为啥子哩</span></span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">0</span>] == v[<span class="number">0</span>] ? u[<span class="number">1</span>] &lt; v[<span class="number">1</span>] : u[<span class="number">0</span>] &gt; v[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = people.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt; a : people)&#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>()+a[<span class="number">1</span>],a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="算法改进：线段树"><a href="#算法改进：线段树" class="headerlink" title="算法改进：线段树"></a>算法改进：线段树</h2><p><em>Leecode执行时间最短的代码</em></p><p><code>树相关的数据结构后期再补</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">执行用时为 <span class="number">16</span> ms 的范例</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">2048</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">int</span> n=people.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">ans</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),[&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp;x,vector&lt;<span class="keyword">int</span>&gt;&amp;y)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> x[<span class="number">0</span>]&lt;y[<span class="number">0</span>]||(x[<span class="number">0</span>]==y[<span class="number">0</span>]&amp;&amp;x[<span class="number">1</span>]&gt;y[<span class="number">1</span>]);&#125;);</span><br><span class="line">        <span class="keyword">int</span> i,j,k,l;</span><br><span class="line">        <span class="comment">//对线段树进行初始化，a[i]表示以i为根的树中空座位数量</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>,k=X,l=<span class="number">1</span>;i&lt;=X*<span class="number">2</span>;i&lt;&lt;=<span class="number">1</span>,k&gt;&gt;=<span class="number">1</span>)<span class="keyword">for</span>(j=i/<span class="number">2</span>;j--;)a[l++]=k;</span><br><span class="line">        <span class="comment">//逐个找座位</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>,k=people[i][<span class="number">1</span>];j&lt;X;--a[j])&#123;</span><br><span class="line">                j&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=a[j])k-=a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[j-X]=people[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础</title>
      <link href="/2021/11/25/linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/25/linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h1><h2 id="文件基础"><a href="#文件基础" class="headerlink" title="文件基础"></a>文件基础</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong><code>删除文件</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch ./test.txt;</span><br><span class="line">rm ./test.txt;</span><br><span class="line">rm -f ./test.txt;//不询问</span><br></pre></td></tr></table></figure><p><strong><code>删除目录</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r aaa;//递归删除当前目录下的aaa目录</span><br><span class="line">rm -rf aaa;;//递归删除当前目录下的aaa目录（不询问）</span><br></pre></td></tr></table></figure><p><strong><code>全部删除</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf *将当前目录下的所有目录全部删除</span><br></pre></td></tr></table></figure><h3 id="重命名-amp-amp-剪切"><a href="#重命名-amp-amp-剪切" class="headerlink" title="重命名&amp;&amp;剪切"></a>重命名&amp;&amp;剪切</h3><p><strong><code>重命名</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 当前目录 新目录</span><br></pre></td></tr></table></figure><p><strong><code>剪切</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /user/tmp/aaa /user;</span><br></pre></td></tr></table></figure><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -r /user/temp/aaa /user#递归复制整个文件夹</span><br><span class="line">\cp -r user/tmp/aaa /user           #如果目标目录下有相同文件，会直接强制覆盖</span><br><span class="line">cp /home/aaa.txt /home/bbb #把aaa.txt文件复制到bbb文件夹里</span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name &quot;hello*&quot;;</span><br></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat helloworld.cpp</span><br><span class="line">cat -n /etc/profile | more              #显示行号、管道符、分页浏览</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">more /etc/profile</span><br><span class="line">    spcae：向下翻页</span><br><span class="line">    enter: 向下翻一行</span><br><span class="line">    q    ： lika</span><br><span class="line">    ctrl+F:向下滚动一屏</span><br><span class="line">    ctrl+B:返回上一屏</span><br><span class="line">    =     ： 显示当前行的行号</span><br><span class="line">    :f    : 输出文件名和当前行的行号</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less 射雕英雄传.txt                     #分屏查看，处理打啊性文件的时候有更高的效率</span><br><span class="line">快捷键：借步度娘</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head -n 5 /etc/profile                #显示前五行</span><br><span class="line">tail -n 5 /etc/profile                #显示后五行</span><br><span class="line">tail -f /etc/profile                  #实时追踪文档的所有更新</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br><span class="line">-n 输出之后不换行</span><br><span class="line">-e 表示对转义字符按照对应的方式进行处理</span><br><span class="line"></span><br><span class="line">echo &quot;hello world &quot; &gt; test.txt #echo重定向</span><br></pre></td></tr></table></figure><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt; a.txt #&gt;输出重定向：会把原来的文件内容覆盖</span><br><span class="line"> #&gt;&gt;不会覆盖原来文件里的内容，在末尾追加</span><br><span class="line">ls -l /home/ &gt; /home/info.txt</span><br></pre></td></tr></table></figure><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root linkToRoot               #给/root建立一个快捷方式</span><br><span class="line">rm -rf linkToRoot                    #hhh</span><br></pre></td></tr></table></figure><h3 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history</span><br><span class="line">!178                                  #执行历史命令中编号为178号的指令</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /home -name helloworld.txt      #根据名称查找该文件</span><br><span class="line">fine / -name *.txt</span><br><span class="line">-user                    #查询属于指定用户的所有文</span><br><span class="line">fine /home -size +20M                    #按照大小查询文件</span><br></pre></td></tr></table></figure><h3 id="过滤和管道符号"><a href="#过滤和管道符号" class="headerlink" title="过滤和管道符号"></a>过滤和管道符号</h3><p><code>grep</code> ：过滤查找</p><p><code>|</code>:管道符，表示将抢一个命令的处理结果输出传递到给后面的命令处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n 显示匹配行及行号</span><br><span class="line">-i 忽略字母大小写</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | grep -n yes</span><br></pre></td></tr></table></figure><h2 id="用户、用户组管理及权限管理"><a href="#用户、用户组管理及权限管理" class="headerlink" title="用户、用户组管理及权限管理"></a>用户、用户组管理及权限管理</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p><strong><code>添加用户</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd xiaoming                     #创建用户成功后，会自动的创建和用户同名的家目录 </span><br><span class="line">useradd -d /home/dog xiaoming        #给新创建的用户创建家目录</span><br></pre></td></tr></table></figure><p><strong><code>给用户分配密码</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd xiaoming </span><br></pre></td></tr></table></figure><p><strong><code>删除用户</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel xiaoming                    #删除用户，但是保留家目录</span><br><span class="line">userdel -r xiaoming                 #删除用户并且删除家目录</span><br></pre></td></tr></table></figure><p><strong><code>查询用户信息</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id root</span><br><span class="line">&gt;&gt;uid=0(root)                        #用户id号</span><br><span class="line">&gt;&gt;gid=0(root)       #所在组的id号</span><br><span class="line">&gt;&gt;组=0(root) #组名</span><br></pre></td></tr></table></figure><p><strong><code>切换用户</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">su xiaoming</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong><code>查看文件的所有者</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ahl</span><br></pre></td></tr></table></figure><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd groupname</span><br><span class="line">groupdel groupname</span><br><span class="line">useradd -g groupname username#创建用户的时候增加组</span><br><span class="line">usermod -g groupname username#修改组</span><br></pre></td></tr></table></figure><h3 id="文件的所有者和所在组"><a href="#文件的所有者和所在组" class="headerlink" title="文件的所有者和所在组"></a>文件的所有者和所在组</h3><p><strong><code>修改文件的所有者</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown tom apple.txt</span><br></pre></td></tr></table></figure><p><strong><code>修改文件所在的组</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#当用户创建了一个文件之后，默认这个文件的所在组就是该用户所在的组</span><br><span class="line">chgrp 组名 文件名</span><br></pre></td></tr></table></figure><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Is -l中显示的内容如下：</span><br><span class="line">-rwxrw-r— 1 root root 1213 Feb 2 09:39 abc</span><br><span class="line">0-9位说明</span><br><span class="line">1）第0位确定文件类型（d,-,第c, b）</span><br><span class="line">2）第1-3位确定所有者（该文件的所有者）拥有该文件的权限。一User</span><br><span class="line">3）第4-6位确定所属组（同用户组的）拥有该文件的权限，一Group</span><br><span class="line">4）第7-9位确定其他用户拥有该文件的权限一Other</span><br></pre></td></tr></table></figure><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>**<code>第一种方式：+ 、 - 、 =变更权限</code> **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u:所有者g:所在组o:其他人a:所有人</span><br><span class="line">chmod u=rwx,g=rx,o=x 文件目录名</span><br><span class="line">chmod o+w 文件目录名</span><br><span class="line">chmod a-x 文件目录名</span><br></pre></td></tr></table></figure><p><strong><code>通过数字权限变更</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 751 文件目录名</span><br></pre></td></tr></table></figure><h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] newowner  file   #改变文件的所有者(如果是目录，则可以用-R对其所有的子文件递归生效)</span><br></pre></td></tr></table></figure><h3 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] newgroup file</span><br></pre></td></tr></table></figure><h2 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h2><h3 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h3><p><strong>gzip</strong> : 将文件压缩成.*gz文件(不会保留原来的文件)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip hello.txt</span><br></pre></td></tr></table></figure><p><strong>gunzip</strong> : 解压缩文件命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip hello.txt.gz</span><br></pre></td></tr></table></figure><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><p><strong>zip</strong> : 压缩文件和目录</p><p><code>-r : 递归压缩,即压缩目录</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r mypackage.zip /home/*</span><br></pre></td></tr></table></figure><p><strong>unzip</strong> : 解压缩文件</p><p><code>-d &lt;dest&gt; : 指定压缩后文件的存放目录</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -d /opt/tmp/ mypackage.zip</span><br></pre></td></tr></table></figure><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-z</td><td>打包同时压缩</td></tr><tr><td align="center">-c</td><td>产生.tar打包文件</td></tr><tr><td align="center">-x</td><td>解包.tar文件</td></tr><tr><td align="center">-v</td><td>显示详细信息</td></tr><tr><td align="center">-f</td><td>指定压缩后的文件名</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#case1 : 压缩多个文件,将/home/a1.txt和/home/a2.txt压缩成a.tar.gz</span><br><span class="line">tar -zcvf a.tar.gz a1.txt a2.txt</span><br><span class="line"></span><br><span class="line">#case2 : 将/home文件夹压缩成 myhome.tar.gz</span><br><span class="line">tar -zcvf myhome.tar.gz /home/*</span><br><span class="line"></span><br><span class="line">#case3 : 将a.tar.gz 解压到当前目录</span><br><span class="line">tar -zxvf a.tar.gz</span><br><span class="line"></span><br><span class="line">#case4 : 将myhome.tar.gz 解压到/opt/目录下(该目录必须存在)</span><br><span class="line">tar -zxvf myhome.tar.gz -C /opt/</span><br></pre></td></tr></table></figure><h2 id="指令运行级别"><a href="#指令运行级别" class="headerlink" title="指令运行级别"></a>指令运行级别</h2><p><strong><code>找回root密码</code></strong></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="查看进程及指令说明"><a href="#查看进程及指令说明" class="headerlink" title="查看进程及指令说明"></a>查看进程及指令说明</h4><h5 id="ps指令查看进程"><a href="#ps指令查看进程" class="headerlink" title="ps指令查看进程"></a>ps指令查看进程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep xxx</span><br><span class="line">ps -aux | grep sshd#查看有没有sshd服务</span><br><span class="line"></span><br><span class="line">pstree [选项]   #用树形结构显示进程信息</span><br><span class="line">-p : 显示进程的PID</span><br><span class="line">-u : 显示进程的所属用户</span><br></pre></td></tr></table></figure><p><strong>指令说明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">•System V展示风格</span><br><span class="line">•USER：用户名称</span><br><span class="line">•PID：进程号</span><br><span class="line">•%CPU：进程占用CPU的百分比</span><br><span class="line">•%MEM：进程占用物理内存的百分比</span><br><span class="line">•VSZ：进程占用的虚拟内存大小（单位：KB）</span><br><span class="line">•RSS：进程占用的物理内存大小（单位：KB）</span><br><span class="line">•TT：终端名称，缩写.</span><br><span class="line">•STAT：进程状态，其中S-睡眠，S-表示该进程是会话的先导进程，N-表示进程拥有比普通优先 文更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</span><br><span class="line">•STARTED：进程的启动时间</span><br><span class="line">•TIME：CPU时间，即进程使用CPU的总时间</span><br><span class="line">•COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/27/IoTKDhkJANCq5M3.png" alt="image-20211127173615213.png"></p><p><strong>全格式显示当前所有进程,查看父进程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | more#以全格式显示当前所有的进程</span><br><span class="line">-e显示所有的进程</span><br><span class="line">-f全格式</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">•是BSD风格</span><br><span class="line">•UID：用户 ID</span><br><span class="line">•PID：进程 ID</span><br><span class="line">•PPID：父进程ID</span><br><span class="line">•c： CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会 降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高</span><br><span class="line">•STIME：进程启动的时间</span><br><span class="line">•TTY：完整的终端名称</span><br><span class="line">•TIME： CPU 时间</span><br><span class="line">•CMD：启动进程所用的命令和参数</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/27/dPGIeBfj1Oy9pSX.png" alt="Snipaste_2021-11-27_17-53-45.png"></p><h5 id="top指令动态监控进程"><a href="#top指令动态监控进程" class="headerlink" title="top指令动态监控进程"></a>top指令动态监控进程</h5><p>top指令和ps指令最大的不同之处在于,top在执行一段时间后可以更新正在运行的进程</p><p><code>top [选项]</code></p><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-d 秒数</td><td align="center">指定top命令每隔几秒更新.默认是3秒,在top命令的交互模式当中可执行的命令</td></tr><tr><td align="center">-i</td><td align="center">使top不现实任何闲置或者僵死进程</td></tr><tr><td align="center">-p</td><td align="center">通过指定监控进程ID来仅仅监控某个进程的状态</td></tr><tr><td align="center">P</td><td align="center">以CPU使用率排序(默认)</td></tr><tr><td align="center">M</td><td align="center">以内存使用率排序</td></tr><tr><td align="center">N</td><td align="center">以PID排序</td></tr></tbody></table><p><em>case1:监视特定用户</em> : <code>top;u username;</code></p><p><em>case2:终止指定的进程</em> :<code>top;k PID</code>;</p><h4 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h4><p><code>kill [选项] PID</code>  :  通过进程号杀死进程</p><p><code>kill 进程名称</code> : 通过进程名杀死进程,也支持通配符,这在系统因负载过大而变得很慢的时候很有用</p><p> <em>case1 : 踢掉某个非法用户登录</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep sshd</span><br><span class="line">kill 4010</span><br></pre></td></tr></table></figure><p><em>case2 : 终止远程登录服务sshd,在适当时候再次重启sshd服务</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep sshd</span><br><span class="line">&gt;3908………  /user/sbin/sshd</span><br><span class="line">kill 3908</span><br></pre></td></tr></table></figure><p><em>case3 : 终止多个gedit编辑器</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall gedit</span><br></pre></td></tr></table></figure><p><em>case 4 : 强制杀掉一个终端</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#终端 : /bin/bash</span><br><span class="line">ps -aux | grep bash</span><br><span class="line">kill -9 4115</span><br></pre></td></tr></table></figure><h3 id="服务-守护进程"><a href="#服务-守护进程" class="headerlink" title="服务(守护进程)"></a>服务(守护进程)</h3><h4 id="service管理指令"><a href="#service管理指令" class="headerlink" title="service管理指令"></a>service管理指令</h4><p><strong>服务本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如（mysql，sshd，防火墙），因此我们又称为守护进程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [start|stop|restart|reload|status]</span><br><span class="line">在CentOS7.0后，不在使用service，而是systemctl</span><br></pre></td></tr></table></figure><p><em>case1 : 查看当前防火墙的状态，关闭防火墙和重启防火墙</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service iptable status</span><br><span class="line">service iptable stop</span><br><span class="line">service iptable start</span><br><span class="line">#关闭或者启用防火墙后,立即生效</span><br><span class="line">#这种方式只是临时生效,当重启系统之后,还是回归到对以前该服务的设置</span><br><span class="line">#如果希望设置某个服务自动启动或者关闭永久生效,要用chkconfig指令</span><br></pre></td></tr></table></figure><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h4><p><code>setup</code> : 查看服务名(虚拟机中)</p><p><code>/etc/init.d</code> : <code>ls -l /etc/init.d</code></p><h4 id="服务的运行级别-runlevel"><a href="#服务的运行级别-runlevel" class="headerlink" title="服务的运行级别(runlevel)"></a>服务的运行级别(runlevel)</h4><p>查看或者修改默认级别：<code>vi/etc/mittab</code><br>Linux系统有7种运行级别（runlevel）：常用的是级别<strong>3</strong>和<strong>5</strong></p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">运行级别0</td><td align="center">系统停机状态，系统默认运行级别不能设为0,否则不能正常启动</td></tr><tr><td align="center">运行级别1</td><td align="center">单用户工作状态，root权限，用于系统维护，禁止远程登陆</td></tr><tr><td align="center">运行级别2</td><td align="center">多用户状态（没有NFS）,不支持网络</td></tr><tr><td align="center">运行级别3</td><td align="center">完全的多用户状态（有NFS）,登陆后进入控制台命令行模式</td></tr><tr><td align="center">运行级别4</td><td align="center">系统未使用，保留</td></tr><tr><td align="center">运行级别5</td><td align="center">X11控制台，登陆后进入图形GUI模式</td></tr><tr><td align="center">运行级别6</td><td align="center">系统正常关闭并重启，默认运行级别不能设为6,否则不能正常启动</td></tr></tbody></table><h4 id="chkconfig指令"><a href="#chkconfig指令" class="headerlink" title="chkconfig指令"></a>chkconfig指令</h4><p>通过chkconfig指令可以给每个服务的各个运行级别设置自启动/关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list</span><br><span class="line">chkconfig --list | grep sshd</span><br><span class="line">chkconfig --level 5 服务名 on/off       #把该服务runlevel=5设置为on/off</span><br><span class="line">chkconfig 服务名 on/off</span><br><span class="line">#chkconfig重新设置服务自启动或关闭,需要重启及其reboot才能生效</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/27/aku8KPJohOD6NCG.png" alt="Snipaste_2021-11-27_22-38-02.png"></p><h4 id="查看系统网络情况-netstat"><a href="#查看系统网络情况-netstat" class="headerlink" title="查看系统网络情况 netstat"></a>查看系统网络情况 netstat</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br><span class="line">-an 按照一定顺序排列输出</span><br><span class="line">-p  显示哪个进程在调用</span><br><span class="line">netstat -anp | grep sshd#查看服务名为sshd的系统网络信息</span><br></pre></td></tr></table></figure><h2 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h2><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab [ ]"></a>crontab [ ]</h4><p>任务调度 ：是指系统在某个时间执行的特定的命令或程序</p><p>任务调度分类：</p><pre><code> 1. 系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等 2. 个别用户工作：如对mysql数据库的备份</code></pre><p><code>crontab [选项]</code></p><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">编辑crontab定时任务</td></tr><tr><td align="center">-l</td><td align="center">查询crontab任务</td></tr><tr><td align="center">-r</td><td align="center">删除当前用户所有的crontab任务</td></tr><tr><td align="center">service crond restart</td><td align="center">重启任务调度</td></tr></tbody></table><p><em>Example：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#每分钟都自动调用ls -l /etc&gt;&gt;/tmp/to.txt</span><br><span class="line">crontab -e</span><br><span class="line">*/1 * * * * ls -l /etc&gt;&gt;/tmp/to.txt</span><br><span class="line">保存退出</span><br><span class="line"></span><br><span class="line">#每分钟当当前日期和日历都追加到/home/mycal文件中</span><br><span class="line">先编写一个文件 /home/mytask2.sh</span><br><span class="line">1. date&gt;&gt;/tmp/mycal    cal&gt;&gt;/tmp/mycal</span><br><span class="line">2. chmod 744 /home/mytask2.sh</span><br><span class="line">3. crontab -e</span><br><span class="line">4. */1 * * * * /home/mytask2.sh</span><br></pre></td></tr></table></figure><p><em>参数细节</em></p><table><thead><tr><th>参数</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个*</td><td>一小时当中有几分钟</td><td>0-59</td></tr><tr><td>第二个*</td><td>一天中有几个小时</td><td>0-23</td></tr><tr><td>第三个*</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第四个*</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td>第五个*</td><td>一周当中的星期几</td><td>0-7(0和7都代表星期日)</td></tr></tbody></table><p><em>特殊符号的说明</em></p><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任意时间。比如每个小时，每分钟</td></tr><tr><td>，</td><td>代表不连续的时间。比如“0 8,12,13 * * * ”代表每天的八点0分,12点0分,13点分执行一次命令</td></tr><tr><td>-</td><td>代表连续的时间范围</td></tr><tr><td>*/n</td><td>代表每个n执行一次命令</td></tr></tbody></table><p><code>case1 : */10 4 15 * *</code> : 每月15号的4点每隔10分钟执行一次命令 </p><h2 id="RPM和YUM"><a href="#RPM和YUM" class="headerlink" title="RPM和YUM"></a>RPM和YUM</h2><h3 id="RPM-RedHat-Package-Manager"><a href="#RPM-RedHat-Package-Manager" class="headerlink" title="RPM(RedHat Package Manager)"></a>RPM(RedHat Package Manager)</h3><h4 id="rpm包的查询"><a href="#rpm包的查询" class="headerlink" title="rpm包的查询"></a>rpm包的查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -q XXX #查询软件包是否安装</span><br><span class="line">rpm -qa | grep XXX #查看所有安装的rpm包</span><br><span class="line">rpm -qi XXX  #查询软件包信息</span><br><span class="line">rpm -ql XXX #查询软件包中的文件</span><br><span class="line">rpm -qf 文件路径  #查询文件所属于哪个rpm包</span><br></pre></td></tr></table></figure><p>rpm包的基本格式 : firefox-45.0.1-1.el6.centos.x86_64.rpm</p><ul><li>名称:firefox</li><li>版本号:45.0.1-1</li><li>适用的操作系统:el6.centos.x86_64(noarch表示通用) </li></ul><h4 id="rpm包的卸载"><a href="#rpm包的卸载" class="headerlink" title="rpm包的卸载"></a>rpm包的卸载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e XXX</span><br><span class="line">rpm -e --npdeps XXX#强制删除(无论该文件是否是另一文件的依赖包)</span><br></pre></td></tr></table></figure><h4 id="rpm包的安装"><a href="#rpm包的安装" class="headerlink" title="rpm包的安装"></a>rpm包的安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh XXX</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">安装</td></tr><tr><td align="center">-v</td><td align="center">提示</td></tr><tr><td align="center">-h</td><td align="center">进度条</td></tr></tbody></table><h3 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h3><p>yum是一个shell前端软件管理器。基于RPM包管理，能够从指定的服务器自动下载rpm包并且安装，可以制动处理依赖性关系，并且一次性安装所有依赖的软件包。需要联网。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep XXX#查询是否有该rpm包</span><br><span class="line">yum install XXX</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法：#Leecode435无重叠区间</title>
      <link href="/2021/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode435%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
      <url>/2021/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A-Leecode435%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法：-Leecode435无重叠区间"><a href="#贪心算法：-Leecode435无重叠区间" class="headerlink" title="贪心算法：#Leecode435无重叠区间"></a>贪心算法：#Leecode435无重叠区间</h1><h2 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><h2 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h2><p>先计算最多能组成多少不重叠的区间，然后用总区间个数减去不重叠区间的个数。</p><p>每次都要选择一个区间结尾最小的，这样留给后面的空间就越大，那么后面能够选的区间的个数就越多。</p><p>由于每个区间都是start&lt;end的，所以利用lamda表达式把所有的区间按照尾排序。</p><p>lamda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>() , intervals.<span class="built_in">end</span>() , [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;u , <span class="keyword">const</span> <span class="keyword">auto</span> &amp;v)&#123;<span class="comment">//如果把auto改成&lt;vector&gt;int类型会快很多</span></span><br><span class="line"><span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; u, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> edge = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= edge)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                edge = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="贪心算法：-Leecode452扎气球"><a href="#贪心算法：-Leecode452扎气球" class="headerlink" title="贪心算法：#Leecode452扎气球"></a>贪心算法：#Leecode452扎气球</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p> 示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>() , points.<span class="built_in">end</span>() , [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp;u , <span class="keyword">const</span> <span class="keyword">auto</span>&amp;v)&#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endrange = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(endrange &gt;= points[i][<span class="number">0</span>])&#123;       <span class="comment">//如果气球有重叠，那么不用管，一根箭就可以戳爆了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            endrange = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针#LeeCode680验证回文字符串Ⅱ</title>
      <link href="/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode680%E9%AA%8C%E8%AF%81%E4%BC%9A%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1/"/>
      <url>/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode680%E9%AA%8C%E8%AF%81%E4%BC%9A%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针-：-LeeCode680验证回文字符串Ⅱ"><a href="#双指针-：-LeeCode680验证回文字符串Ⅱ" class="headerlink" title="双指针 ： #LeeCode680验证回文字符串Ⅱ"></a>双指针 ： #LeeCode680验证回文字符串Ⅱ</h1><h2 id="题目重述："><a href="#题目重述：" class="headerlink" title="题目重述："></a>题目重述：</h2><p>给定一个非空字符串s，最多删除一个字符，判断是否能够成为回文字符串</p><p>实例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abca&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure><p>实例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>自己的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//这里显得多少有带你幼稚了。而且错误出现在这里</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>] == s[j] )&#123;</span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == s[j<span class="number">-1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思考：不用总是使用count等辅助变量。试试其他的思路！</p><p>关键：只允许失误一次</p><p>题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">length</span>()<span class="number">-1</span> ; i &lt;= j ; i++  ,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])&#123;<span class="comment">//唯一一次的失误机会</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isPalindrome</span>(s , i+<span class="number">1</span> , j) || <span class="built_in">isPalindrome</span>(s , i , j<span class="number">-1</span>);<span class="comment">//判断跳过左右两个字符是否会成为回文</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s , <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i++] != s[j--])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针#LeeCode524通过删除字母匹配到字典里最长单词</title>
      <link href="/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode524%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"/>
      <url>/2021/11/24/%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode524%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针：-LeeCode524通过删除字母匹配到字典里最长单词"><a href="#双指针：-LeeCode524通过删除字母匹配到字典里最长单词" class="headerlink" title="双指针：#LeeCode524通过删除字母匹配到字典里最长单词"></a>双指针：#LeeCode524通过删除字母匹配到字典里最长单词</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。</p><p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abpcplea&quot;, dictionary = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abpcplea&quot;, dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>自己的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;string&gt; save;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;<span class="comment">//1</span></span><br><span class="line">             <span class="keyword">int</span> pointer1 = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> pointer2 = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">while</span>(pointer1 != n)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(s[pointer1++] == dictionary[i][pointer2])&#123;</span><br><span class="line">                     pointer2++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(pointer2 == dictionary[i].<span class="built_in">length</span>())&#123;</span><br><span class="line">                save.<span class="built_in">push_back</span>(dictionary[i]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(save.<span class="built_in">begin</span>() == save.<span class="built_in">end</span>())&#123;<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">            string temp = save[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;save.<span class="built_in">size</span>();i++)&#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">if</span>(save[i] &lt; save[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    temp = save[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>1、2两处使用了两次循环。但是，这是两个完全相统的循环。所以是否可以只使用一次循环就完成？</p><p>3处的判断过于冗余</p><p>题解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String t : dictionary)&#123;</span><br><span class="line">            <span class="keyword">int</span> pointer1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> pointer2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pointer1 &lt; s.length() &amp;&amp; pointer2 &lt; t.length())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(pointer1++) == t.charAt(pointer2))&#123;</span><br><span class="line">                    pointer2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pointer2 == t.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.length() &gt; res.length() || ( t.length() == res.length() &amp;&amp; t.compareTo(res) &lt; <span class="number">0</span>))&#123;</span><br><span class="line">                    res = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快慢双指针#LeeCode141环形链表</title>
      <link href="/2021/11/24/%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/24/%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88-LeeCode141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="快慢双指针：-LeeCode141环形链表"><a href="#快慢双指针：-LeeCode141环形链表" class="headerlink" title="快慢双指针：#LeeCode141环形链表"></a>快慢双指针：#LeeCode141环形链表</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>示例1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><h2 id="题解：Floyd判圈法"><a href="#题解：Floyd判圈法" class="headerlink" title="题解：Floyd判圈法"></a>题解：Floyd判圈法</h2><p>算法思想：假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;<span class="comment">//判断条件是两个何时相等</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)&#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;<span class="comment">//每次走一格</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;<span class="comment">//每次走两格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1：巧用或运算。先判断前件，如果前件不满足，则直接不考虑后件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2021/11/24/Git/"/>
      <url>/2021/11/24/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="工作区，暂存区，本地库"><a href="#工作区，暂存区，本地库" class="headerlink" title="工作区，暂存区，本地库"></a>工作区，暂存区，本地库</h1><h2 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init//在某个文件夹内执行该指令，该文件夹就会成为本地的workspace</span><br></pre></td></tr></table></figure><p>git init生成.git文件，是隐藏文件，如果需要访问需要<code>ls -lA</code>。</p><p>.git目录中存放的是本地库相关的子目录和文件，不要乱动</p><h3 id="设置签名-：-区分不同开发人员的身份（和登录远程库的账号密码无关）"><a href="#设置签名-：-区分不同开发人员的身份（和登录远程库的账号密码无关）" class="headerlink" title="设置签名 ： 区分不同开发人员的身份（和登录远程库的账号密码无关）"></a>设置签名 ： 区分不同开发人员的身份（和登录远程库的账号密码无关）</h3><p>项目级别/仓库级别：仅在当前工作区有效</p><p>系统用户级别：当前操作系统的用户范围</p><p>项目级别优先于系统用户级别，如果没有项目级别就是用系统用户级别的签名</p><p>查看签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config -l             //所有的配置 = system+global</span><br><span class="line">git config --system --list    //系统配置</span><br><span class="line">git config --global --list    //全局配置，用户自己的配置</span><br></pre></td></tr></table></figure><p>配置签名： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;liyuan&quot;</span><br><span class="line">git config user.email &quot;liyuan_sunny@163.com&quot;//保存在./.git/config文件中</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;liyuan&quot;</span><br><span class="line">git config --gloabl user.email &quot;liyuan_sunny@163.com&quot;   //保存在~/.gitconfig</span><br></pre></td></tr></table></figure><h3 id="配置ssh免密登录"><a href="#配置ssh免密登录" class="headerlink" title="配置ssh免密登录"></a>配置ssh免密登录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">rm -rf .ssh</span><br><span class="line">ssh-keygen -t rsa -C liyuan_sunny@163.com</span><br><span class="line">cd .ssh</span><br><span class="line">cat id_isa.pub</span><br><span class="line">复制公钥，到github</span><br><span class="line">git remote add origin_ssh git@…………</span><br><span class="line">git push origin_ssh helloworld.cpp</span><br></pre></td></tr></table></figure><h3 id="SSL验证错误"><a href="#SSL验证错误" class="headerlink" title="SSL验证错误"></a>SSL验证错误</h3><p>在提交的时候遇到了报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/LYinGithub/hello-world.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>解决方法：但是每次push都需要这么一串代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status //查看当前工作区、暂存区的状态</span><br><span class="line">vim helloworld.txt  //创建一个未追踪的文件</span><br><span class="line">git add &lt;文件名&gt;   //只能用git add将本地未追踪的文件添加到暂存区</span><br><span class="line">git rm --cached &lt;文件名&gt;    //将暂存区的取回</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>快照流。提交没有变的部分是提供一个指向上一个对象的指针，存储差异。考虑到git的轻量级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit &lt;文件名&gt;          //暂存区的修改提交到本地库。</span><br><span class="line">git commit -m &quot;注释&quot; &lt;文件名&gt; //当场写注释</span><br></pre></td></tr></table></figure><p>如果修改该文件已追踪的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//第一次提交</span><br><span class="line">vim helloworld.txt;</span><br><span class="line">git add helloworld.txt;</span><br><span class="line">git commit -m &quot;the first test&quot; helloworld.txt</span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">vim helloworld.txt</span><br><span class="line"></span><br><span class="line">//第二次提交</span><br><span class="line">git add + git commit -m //由于已经追踪过该文件，所以可以用git add添加到暂存区，也可以直接commit</span><br><span class="line">git commit -a</span><br><span class="line">(git reset HEAD helloworld.txt)//可以使用这个命令从暂存区取回</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="git-log-：-查看当前本地库的提交记录"><a href="#git-log-：-查看当前本地库的提交记录" class="headerlink" title="git log ： 查看当前本地库的提交记录"></a>git log ： 查看当前本地库的提交记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log                    //空格向下翻页，b向上翻页，q退出</span><br><span class="line">git log --pretty=oneline   //每个日志只显示一行</span><br><span class="line">git log --oneline</span><br><span class="line">git reflog                 //查看回退到各个版本HEAD指针需要走几步</span><br></pre></td></tr></table></figure><h3 id="git-reset-git-revert撤销变更"><a href="#git-reset-git-revert撤销变更" class="headerlink" title="git reset/git revert撤销变更"></a>git reset/git revert撤销变更</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard hashindex//前进后退都行       HEAD^^//本地</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD~100//回滚100个版本（~num &amp;&amp; ^ 的相对引用）</span><br><span class="line">git reset --hart HEAD^^  //回滚2个版本</span><br><span class="line"></span><br><span class="line">git revert //云端</span><br></pre></td></tr></table></figure><p>–soft参数 ： 仅仅是在本地库移动HEAD指针（会显得缓存区的文件出现了修改。其实实际上没有改，是因为本地库回滚，看样子暂存区修改了）</p><p>–mixed参数：在本地库移动HEAD指针，并且重置暂存区（会显得工作区的文件出现了修改）</p><p>–hard参数：移动本地库的HEAD指针，重置暂存区，重置工作区</p><h3 id="rm-lt-filename-gt"><a href="#rm-lt-filename-gt" class="headerlink" title="rm &lt;filename&gt;"></a>rm &lt;filename&gt;</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;filename&gt; //删除这个文件，通常指的是提交到本地库之后删除这个文件</span><br><span class="line">rm helloworld.txt</span><br><span class="line">ll              //发现工作区已经没有这个文件了</span><br><span class="line">git add helloworld.txt    //把删除helloworld.txt的这条指令添加到暂存区</span><br><span class="line">git commit -m &quot;hhh&quot; helloworld.txt;</span><br><span class="line">git status               //发现工作区和缓存区清空</span><br><span class="line">git reset HEAD^              //可以通过上一个版本找回这个文件</span><br></pre></td></tr></table></figure><p>如果已经把删除的指令提交到暂存区，但是还没提交到本地库。怎么取回这条操作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD;</span><br></pre></td></tr></table></figure><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld.txt             </span><br><span class="line">git diff                    //无其他参数：和暂存区比较</span><br><span class="line">git diff HEAD helloworld.txt   //和本地库比较</span><br><span class="line">git diff HEAD^^                //和本地库的前几个版本比较</span><br></pre></td></tr></table></figure><h3 id="git-tag-git-describe………………（用到再说）"><a href="#git-tag-git-describe………………（用到再说）" class="headerlink" title="git tag / git describe………………（用到再说）"></a>git tag / git describe………………（用到再说）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1 C1//为C1创建一个名叫V1的标签</span><br><span class="line">git describe//返回距离最近标签之间的版本差距信息</span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v               //查看所有分支名</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch bugFix//创建一个名叫bugFix的分支，内容是从master分支复制而来</span><br><span class="line">git branch -b bugFix C1//在C1处创建一个名叫bugFix的分支并且使指针指向他</span><br><span class="line">git branch -f main HEAD//强制将main指针移动到HEAD指针所在的位置，这个不一定是指针，也可以是任意一个提交版本的位置，这个命令就是操控分支指针的命令</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout bugFix//当前在bugFix分支</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>git merge能有有效的保护历史</p><ol><li>切换到接受修改的分支（被合并，增加新内容）</li><li>执行merge命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge bugFix//目前指针在m。main吸收main和bugFix两个分支，之后指针仍然指向main</span><br></pre></td></tr></table></figure><h4 id="git-merge-git-rebase-git-cherry-pick（未实战）"><a href="#git-merge-git-rebase-git-cherry-pick（未实战）" class="headerlink" title="git merge/git rebase/git cherry-pick（未实战）"></a>git merge/git rebase/git cherry-pick（未实战）</h4><p>git rebase能够让整个项目看起来极其线性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git rebase main//目前指针在bugFix，将bugFix复制到main的新的提交，之后指针仍然指向bugFix </span><br><span class="line">//bugFix原来的分支仍然存在</span><br><span class="line"></span><br><span class="line">git rebase bugFix//因为此时bugFix指向main，所以git知识简单的把main分支的引用向前移动了一下</span><br><span class="line"></span><br><span class="line">git rebase -i HEAD~4//出现UI窗口，你可以决定如何复制</span><br><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>git cherry-pick实现自由复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick C1 C2 C3;</span><br></pre></td></tr></table></figure><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p> 冲突内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaaaa</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD   /*</span><br><span class="line">hhhhhhhhhhhh当前分支得到内容</span><br><span class="line">=============     *//*另一分支的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;master*/</span><br><span class="line">iiiiiiiiiiiii</span><br><span class="line">jjjjjjjjjjjj</span><br></pre></td></tr></table></figure><p>解决冲突 ： 删除掉字符就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld.txt          //删除掉不需要的东西</span><br><span class="line">git add helloworld.txt                  //使用git add标志文件为已解决。此时所有冲突都被解决，但是仍然没有合并</span><br><span class="line">git commit -m &quot;ok merge&quot;                //不带文件名</span><br></pre></td></tr></table></figure><h1 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h1><h2 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote -v       //查看本地现有的地址别名</span><br><span class="line">git remote add origin https://github.com/LYinGithub/hello-world.git  //给这串地址取别名为origin</span><br></pre></td></tr></table></figure><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><ol><li>完整的把远程库下载到本地</li><li>创建origin远程地址别名</li><li>初始化本地库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LYinGithub/hello-world.git</span><br></pre></td></tr></table></figure><h3 id="git-Push"><a href="#git-Push" class="headerlink" title="git Push"></a>git Push</h3><p>将当前分支推送到云端仓库。</p><p>远程仓库接收到了更新，远程仓库的main指向新的更新，同时我们的远程分支<code>origin/main</code>也同时更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git Push</span><br></pre></td></tr></table></figure><h4 id="git-push的参数-1-：-git-push-lt-remote-gt-lt-place-gt"><a href="#git-push的参数-1-：-git-push-lt-remote-gt-lt-place-gt" class="headerlink" title="git push的参数 1 ： git push  &lt;remote&gt; &lt;place&gt;"></a>git push的参数 1 ： git push  &lt;remote&gt; &lt;place&gt;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main(指定place参数,即要推送的分支)</span><br></pre></td></tr></table></figure><p>翻译过来就是：<strong>切换到本地仓库的“main”</strong>，获取所有的提交，再到远程仓库”orirgin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去</p><p>如果不指定参数会发生什么?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout C0</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>什么也不会发生，因为我们所检出的HEAD没有跟踪任何分支</p><h4 id="git-push的参数2：git-push-origin-lt-source-gt-lt-destination-gt"><a href="#git-push的参数2：git-push-origin-lt-source-gt-lt-destination-gt" class="headerlink" title="git push的参数2：git push origin &lt;source&gt; &lt;destination&gt;"></a>git push的参数2：git push origin &lt;source&gt; &lt;destination&gt;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin f00^:main//把本地库的foo的父提交推送到远端仓库的main分支中</span><br></pre></td></tr></table></figure><p>如果要推送的分支不存在会怎么样？git会在你远程仓库中根据提供的名称创建这个分支</p><p>同时本地也会在提交的节点创建origin/newBranch远程分支追踪远程仓库中的newBranch分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main:newBranch</span><br></pre></td></tr></table></figure><h4 id="git-push的参数3：奇怪的-lt-source-gt"><a href="#git-push的参数3：奇怪的-lt-source-gt" class="headerlink" title="git push的参数3：奇怪的&lt;source&gt;"></a>git push的参数3：奇怪的&lt;source&gt;</h4><p>通过push传控制source，可以删除远程仓库中的side分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :side</span><br></pre></td></tr></table></figure><h4 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h4><p>必须基于远程库的最新分支才能够push，否则会被git决绝请求—-&gt;使用rebase调整本地库的工作</p><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase origin/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>需要更新本地仓库的远程分支，然后用rebase将我们的工作移动到最新的提交记录，然后再用git push推送到远程仓库</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>将远程仓库的更新下载到本地，但是不修改本地文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch//把远程仓库的更新下载到本地，同时远程分支origin/main也被更新，然而原本的main不会改变</span><br></pre></td></tr></table></figure><h4 id="git-fetch的参数1：与git-push十分相似，知识方向相反罢了"><a href="#git-fetch的参数1：与git-push十分相似，知识方向相反罢了" class="headerlink" title="git fetch的参数1：与git push十分相似，知识方向相反罢了"></a>git fetch的参数1：与git push十分相似，知识方向相反罢了</h4><p>在远程仓库的<code>foo</code>分支上，获取所有本地不存在的提交，放到本地的origin/foo上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br><span class="line">git checkout origin/foo</span><br><span class="line">cat helloworld.txt         //可以看到本地库里helloworld的变化了</span><br></pre></td></tr></table></figure><p>问：为什么不是将git放到本地的<code>foo</code>分支（及抓取后将文件放在本地库，但是没有修改工作区的文件）</p><p>答：因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 <code>git fetch</code> 课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）</p><h4 id="git-fetch的参数2："><a href="#git-fetch的参数2：" class="headerlink" title="git fetch的参数2："></a>git fetch的参数2：</h4><p>git将<code>foo~1</code>解析成一个origin的仓库位置，然后将那些提交记录下载到本地的bar（存在）分支，注意由于制定了目标分支，我们其他的分支都没有被更新</p><p>注：如果本地的bar分支不存在怎么办？git会创建一个bar分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo~1:bar</span><br></pre></td></tr></table></figure><h4 id="git-fetch没有参数："><a href="#git-fetch没有参数：" class="headerlink" title="git fetch没有参数："></a>git fetch没有参数：</h4><p>如果<code>git fetch</code>没有参数，它会下载所有的提交记录到各个远程分支</p><h4 id="git-fetch参数4：奇怪的-lt-source-gt"><a href="#git-fetch参数4：奇怪的-lt-source-gt" class="headerlink" title="git fetch参数4：奇怪的&lt;source&gt;"></a>git fetch参数4：奇怪的&lt;source&gt;</h4><p>fetch一个空source到本地，会在本地创建一个新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin :bugFix</span><br></pre></td></tr></table></figure><h3 id="git-Pull-git-fetch-git-merge"><a href="#git-Pull-git-fetch-git-merge" class="headerlink" title="git Pull = git fetch + git merge"></a>git Pull = git fetch + git merge</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull = git fetch + git merge origin/main</span><br></pre></td></tr></table></figure><p>注意：git pull必须基于本地remote tracking branch</p><p>否则git pull –rebase会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">side3 is not a remote tracking branch!I don&#x27;t know where to pull</span><br></pre></td></tr></table></figure><h4 id="git-pull的参数"><a href="#git-pull的参数" class="headerlink" title="git pull的参数"></a>git pull的参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin foo = git fetch origin foo</span><br><span class="line">git merge origin/foo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin bar~1:bugFix = git feetch origin bar~1:bugFix</span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure><h2 id="远程追踪分支：origin-main与remote-tracking"><a href="#远程追踪分支：origin-main与remote-tracking" class="headerlink" title="远程追踪分支：origin/main与remote tracking"></a>远程追踪分支：origin/main与remote tracking</h2><h3 id="关于origin-main"><a href="#关于origin-main" class="headerlink" title="关于origin/main"></a>关于origin/main</h3><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout origin/main</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>HEAD会直接变成分离状态。而origin/main不会更新。</p><p>由于remote tracking机制的存在，main背设定为追踪origin/main，这意味着main分支制定了推送的目的地以及拉去后合并的目标</p><h3 id="自定义追踪origin-main-：-git-checkout-b-branchname-origin-main"><a href="#自定义追踪origin-main-：-git-checkout-b-branchname-origin-main" class="headerlink" title="自定义追踪origin/main ： git checkout -b branchname origin/main"></a>自定义追踪origin/main ： git checkout -b branchname origin/main</h3><p>可以自定义任意分支追踪origin/main，然后分支就会像main分支一样隐含的push目的地以及merge的目标。</p><p>//创建一个名为totalNotMain分支，然后追踪远程分支origin/main ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b tootalNotMain origin/main</span><br></pre></td></tr></table></figure><p>//pull : 使用foo来追踪origin/main，在pull之后，foo会跟随origin/main更新，然而main没有被更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo origin/main</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>//push：由于git checkout -b foo本身就是创建一个分支，然后使指针指向他。所以提交之后main不会更改，而foo会更改</p><p>//push之后origin/main会到达foo的位置，而main会停留在原地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b foo origin/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="自定义追踪-：-git-branch-u"><a href="#自定义追踪-：-git-branch-u" class="headerlink" title="自定义追踪 ： git branch -u"></a>自定义追踪 ： git branch -u</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/main foo</span><br></pre></td></tr></table></figure><p>如果当前节点在foo上，那么还可以省略foo ： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/main</span><br></pre></td></tr></table></figure><h1 id="git跨团队协作"><a href="#git跨团队协作" class="headerlink" title="git跨团队协作"></a>git跨团队协作</h1><h2 id="邀请加入团队"><a href="#邀请加入团队" class="headerlink" title="邀请加入团队"></a>邀请加入团队</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. repository-&gt;setting-&gt;collaborators+被邀请人的GitHub账号</span><br><span class="line">2. 复制链接，发送给那个人</span><br><span class="line">3. 输入链接，接受</span><br></pre></td></tr></table></figure><h2 id="不邀请进入团队"><a href="#不邀请进入团队" class="headerlink" title="不邀请进入团队"></a>不邀请进入团队</h2><ol><li>fork一份仓库，此时仓库属于自己</li><li>git clone到本地库</li><li>修改</li><li>git push到远程库</li><li>发送pull request请求</li><li>审核</li><li>git merge</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
